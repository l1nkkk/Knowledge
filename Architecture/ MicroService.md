- [微服务](#%E5%BE%AE%E6%9C%8D%E5%8A%A1)
  - [什么是微服务](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1)
  - [内聚性](#%E5%86%85%E8%81%9A%E6%80%A7)
  - [代码库多小算小](#%E4%BB%A3%E7%A0%81%E5%BA%93%E5%A4%9A%E5%B0%8F%E7%AE%97%E5%B0%8F)
  - [自治性](#%E8%87%AA%E6%B2%BB%E6%80%A7)
  - [主要好处](#%E4%B8%BB%E8%A6%81%E5%A5%BD%E5%A4%84)
  - [SOA（面向服务的架构）](#SOA%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84)
    - [共享库](#%E5%85%B1%E4%BA%AB%E5%BA%93)
      - [优点](#%E4%BC%98%E7%82%B9)
      - [缺点](#%E7%BC%BA%E7%82%B9)
    - [模块](#%E6%A8%A1%E5%9D%97)
      - [OSGI（开放服务网关协议）--Java](#OSGI%E5%BC%80%E6%94%BE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE--Java)
      - [Erlang](#Erlang)
      - [优缺点](#%E4%BC%98%E7%BC%BA%E7%82%B9)
  - [没有银弹](#%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9)
- [如何建模服务](#%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1)
  - [松耦合](#%E6%9D%BE%E8%80%A6%E5%90%88)
  - [高内聚](#%E9%AB%98%E5%86%85%E8%81%9A)
  - [限界上下文](#%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87)
  - [MusicCrop的业务领域](#MusicCrop%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F)
  - [模块和服务](#%E6%A8%A1%E5%9D%97%E5%92%8C%E6%9C%8D%E5%8A%A1)
  - [过早划分](#%E8%BF%87%E6%97%A9%E5%88%92%E5%88%86)
  - [划分误区](#%E5%88%92%E5%88%86%E8%AF%AF%E5%8C%BA)
  - [逐步划分上下文（服务细分）](#%E9%80%90%E6%AD%A5%E5%88%92%E5%88%86%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%8D%E5%8A%A1%E7%BB%86%E5%88%86)
- [集成](#%E9%9B%86%E6%88%90)
  - [集成时注意点](#%E9%9B%86%E6%88%90%E6%97%B6%E6%B3%A8%E6%84%8F%E7%82%B9)
  - [集成方式](#%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F)
    - [共享数据库](#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93)
    - [同步与异步](#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5)
    - [编排与协同](#%E7%BC%96%E6%8E%92%E4%B8%8E%E5%8D%8F%E5%90%8C)
  - [远程过程调用](#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8)
  - [REST](#REST)
    - [REST与HTTP](#REST%E4%B8%8EHTTP)
    - [超媒体作为程序状态引擎（HATEOAS）](#%E8%B6%85%E5%AA%92%E4%BD%93%E4%BD%9C%E4%B8%BA%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%BC%95%E6%93%8EHATEOAS)
    - [JSON还是XML](#JSON%E8%BF%98%E6%98%AFXML)
    - [留心过多的约定](#%E7%95%99%E5%BF%83%E8%BF%87%E5%A4%9A%E7%9A%84%E7%BA%A6%E5%AE%9A)
    - [基于HTTP的REST的缺点](#%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84REST%E7%9A%84%E7%BC%BA%E7%82%B9)
  - [实现基于事件的异步协作方式](#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F)
    - [技术选择](#%E6%8A%80%E6%9C%AF%E9%80%89%E6%8B%A9)
    - [异步架构的复杂性](#%E5%BC%82%E6%AD%A5%E6%9E%B6%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7)
    - [服务即状态机](#%E6%9C%8D%E5%8A%A1%E5%8D%B3%E7%8A%B6%E6%80%81%E6%9C%BA)
    - [响应式扩展](#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%89%A9%E5%B1%95)
    - [微服务世界中的DRY和代码重用的危险](#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84DRY%E5%92%8C%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9)
      - [客户端库](#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93)
    - [按引用访问](#%E6%8C%89%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE)
  - [版本管理](#%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86)
    - [尽可能推迟](#%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8E%A8%E8%BF%9F)
    - [及早发现破坏性修改](#%E5%8F%8A%E6%97%A9%E5%8F%91%E7%8E%B0%E7%A0%B4%E5%9D%8F%E6%80%A7%E4%BF%AE%E6%94%B9)
    - [使用语义化的版本管理](#%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86)
    - [不同版本接口共存](#%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E6%8E%A5%E5%8F%A3%E5%85%B1%E5%AD%98)
    - [同时使用多个版本服务](#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E6%9C%8D%E5%8A%A1)
- [部署](#%E9%83%A8%E7%BD%B2)
# 微服务
## 什么是微服务
微服务就是一些协同工作小而自治的服务。

## 内聚性
在单块系统中，通常会创建一些抽象层或者模块来保证内聚性。（单一职责原则：把因相同的原因而变化的东西聚合一起，而把因不同原因而变化的东西分离开来）

微服务将该理念应用在独立的服务商。

## 代码库多小算小
- 一个微服务应该可以在**两周内**完全重写————Jon Eaves
- 你不再觉得你代码库过大，可能它就足够小了
- 该服务是否能够很好地与团队结构相匹配。如果代码库过大，一个小团队无法正常维护，那么很显然应该将其拆成小的

服务越小的优点和缺点也越明显。越小，独立性带来的发布管理越复杂。

## 自治性
服务之间通过网络进行通信，通过暴露API来进行通信，API实现方式应该与具体技术无关。
- 判断服务是否很好解耦的黄金法则  
  **是否能够修改一个服务并对其进行部署，而不影响任何服务。**


## 主要好处
- 技术异构性。比如现在有一功能使用其他技术能够使某个业务效率更好，如果单体模式下，对整个系统会产生巨大影响，而微服务就不会，可以选择风险最小的服务采用新技术。
- 弹性。服务的边界就是一个很显然的舱壁。单块服务系统中，服务不可用，所有功能都不可用。使用微服务可以恨到处理服务不可用和功能降级。
- 方便扩展。单体系统如果要扩展只能扩展整体。而微服务的扩展就方便了很多。
- 简化部署。如果是单体系统，修改一行代码带来的影响很大，风险很大，这样导致更新频率低，最后发布出来的时候两次发布之间的差异很大，差异越大，出错可能性越大。在微服务中，如果出现问题，也只是影响一个服务，并且可以快速回滚。
- 与开发组织结构相匹配。避免出现过大代码库，从而获得理想的团队大小和生产力，避免异地团队出现。
- 可组合性。现在除了PC，还有Web、原生应用、移动端等等平台，通过各个服务的拼接和复用可以避免很多代码的重复。
- 对替代性的优化。有的遗留系统大而且旧，所能支持的硬件是二十几年前的，但是取代这样的代码工作量大风险高。如果是微服务对于这种替换的操作就很容易

## SOA（面向服务的架构）
是一种设计方法，其中包含多个服务，而服务之 间通过配合最终提供一系列功能。  
- 实施SOA的时候会遇到一些问题：  
  通信协议（如SOAP）如何选择，第三方中间件如何选择，服务粒度如何确定等  
- 现有的SOA并不能帮助你把很大的应用划分小。它没有提到多大算大，也没有讨论如何在显示世界中有效防止服务之间的过度耦合。
- **微服务是SOA的一种特定方法**

##其他分解技术
### 共享库
就是代码分解成多个库
#### 优点
- 团队和服务通过库共享功能
- 库可以重用
#### 缺点
- 技术无法异构。
- 不方便扩展。
- 部署不方便。除非用动态链接库，否则每次都需要重新部署整个进程。
- 弹性差。没有明显接缝来建立架构安全，无法确保系统弹性。

### 模块
允许对模块进行生命周期管理，可以把模块部署到运行的进程中，并且可以不停止整个进程的前提对某个模块进行修改。

#### OSGI（开放服务网关协议）--Java
Java本身并不支持模块概念。复杂度远远大于其带来的好处

#### Erlang
很成熟，语言本身支持模块。支持同时运行同一个模块的多个版本，从而可以优雅的模块升级。对模块可以停止、重启、升级等操作。

#### 优缺点
还是和共享库一样。但是其部署可能方便一些。

## 没有银弹
不是万能药，需要面对所有分布式系统的复杂性，在部署，测试，监控等方面需要做很多工作。还需要处理类似分布式事务和CAP相关问题。

# 如何建模服务
以一个专辑电商MusicCorp为例  
- 一个赢得世界的方法：保证自己很容易对应用进行修改。  
- 需要专注于：松耦合，高内聚

## 松耦合
如果修改一个服务不需要修改另一个服务，那么就做到了服务之间的松耦合。  
一个松耦合的服务应该 **尽可能少** 地知道与之协作的那些服务的信息。也就是说限制服务之间调用形式的数量。

## 高内聚
把相关的聚集在一起，不相关放在别处。  
- 好处
  - 修改的时候只需要修改一处
  - 修改后可以尽快发布
## 限界上下文
(推荐：Eric Evans《领域驱动设计》)
- 定义：
  - 一个显示边界限定的特定职责。
  - 就像是细胞膜，定义什么在细胞内，什么在细胞外，并且规定了什么物质可以通过细胞膜。
  - 限界上下文中的东西分为两部分，一部分不需要与外部通信，另一部分则需要。

## MusicCrop的业务领域
![](pic/1.png)  
详见3.3.1
![](pic/2.png)  
- 许多数据模型对内对外有两种表示方式。
- 同一个名字在不同的上下文有着完全不同的含义。比如退货对于客户和仓库来说是完全不同的含义意味，需要不同的操作。

## 模块和服务
- 可以现在在单块系统中根据内部的限界上下文，使用模块同时使用共享(对外)和隐藏模型(对内)进行建模。  
- 然后通过模块的边界，可以使其成为微服务边界的候选。一般，微服务应该清晰地和限界上下问保持一致。  
- 在熟练了之后可以省去现在单块系统中使用模块这个步骤。
- 如果边界弄错后面修复的代价很大，所以最好先等系统稳定了之后，在将模块划分出去成为微服务。

## 过早划分
 过早的将一个系统划分为微服务的代价非常高，尤其在面对新领域的时候。很多时候将已有的代码划分为微服务要比从头开始构建微服务简单许多。

## 划分误区
应该从上下文来考虑微服务，而不应该简简单单把数据库操作集合成一个模块。  
仓库可能需要库存清单，财务可能需要月末账目，这些都是基于数据库的CRUD。为了实现这些可能需要存储信息的模型，但是不能简简单单的基于CRUD来划分服务，这样会导致模型贫血。(l1nkkk：可能就是有些服务压力很大，有些很小)

## 逐步划分上下文（服务细分）
一开始粗粒度划分，当发现合适缝隙后，再进一步划分出哪些嵌套的上下文。比如仓库可以前考订单处理，库存管理，货物接受这些上下文。
- 方法
  - 嵌套的上下文对外界不可见，发出的请求被透明地映射到两个或者更多的服务上，呈现嵌套式。  
  ![](pic/3.png)
  - 嵌套的上下文对外界可见。服务都是顶层微服务。  
  ![](pic/4.png)  

如果不同子服务是不同团队维护的，那么可能会比较希望都是顶层微服务。  
如果都是一个团队，嵌套是可能更好，因为**组织结构和软件架构会互相影响**(第十章详述)。另一点就是使得架构更加成块可以更好的测试。比如，测试仓库的消费方服务时，不需要对仓库上下文中的每个服务进行**打桩**，只需要专注与粗粒度的API即可。当考虑更大范围的测试的时候，也能给你一定的单元隔离，比如我可以有这样的一种端到端测试，该测试会使用仓库上下文中的所有服务，但其他的所有协作者可以做打桩处理。(第七章详述)

# 集成
如何将多个服务继承为一体，现阶段有许多实现方式，SOAP，XML-RPC，REST，Protocol Buffer等等，在此之前我们需要考虑，到底希望从这些数据中得到什么。
## 集成时注意点
- ** 避免破坏性修改**  
  避免服务的修改导致消费方的修改，比如一个响应中添加一个字段，已有消费方不应该受到影响。

- **保证API的技术无关性**  
  保证微服务之间通信方式的技术无关性很重要，因为IT行业变化很快。

- **使你的服务易于消费方使用**  
  理想情况下，消费方可以使用任何技术来实现。  
  也可以提供客户端库，但是这样会带来一些耦合。

- **隐藏内部实现细节**
  如果被消费方依赖服务细节，那么如果细节变化，就会使消费者跟着调整，而这是我们想要避免的。

## 集成方式
### 共享数据库
![](pic/5.png)

**缺点：**
- 外部系统能够查看内部实现细节，并与其绑定在一起。
- 如果决定更好的表示数据或者增加可维护性而修改表结构的话，消费放就无法进行工作。比如帮助台如何管理客户，这就需要修改数据库。为了不影响其他服务，必须小心修改与其他服务相关的表结构，然后对相关的服务做回归测试。
> 回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。  
> 回归测试作为软件生命周期的一个组成部分，在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。在渐进和快速迭代开发中，新版本的连续发布使回归测试进行的更加频繁，而在极端编程方法中，更是要求每天都进行若干次回归测试。因此，通过选择正确的回归测试策略来改进回归测试的效率和有效性是很有意义的。

- 消费方与特定的技术绑定在一起。如果想把关系型数据库换成非关系型，这样很难替换数据库。可见隐藏实现细节(暴露了使用mysql)非常重要，因为其让我们的服务有一定自治性，可以轻易地修改其内部实现。破坏松耦合。

- 肯定有一部分逻辑负责对客户进行修改。如果消费方直接操作数据库，它们需要对这些逻辑负责。对数据库进行操作的相似逻辑可能会出现在很多服务中。修复一个bug可能要修改多个地方，破坏内聚性。
  

### 同步与异步
- 如果使用同步通信，发起一个远程服务调用后，调用方会阻塞自己并等待整个操作的完成。如果使用异步通信，调用方不需要等待操作完成就可以返回，甚至可能不需要关心这个操作完成与否。  
- 同步可以知道事情成功与否，异步效率比较高，且相对复杂。  
- 有着各自的协作风格，即请求/响应或者基于事件。

### 编排与协同

当考虑具体实现时，有两种架构风格可以采用，即编排和协同。  
使用**编排(orchestration)** 的话，我们会依赖于某个中心大脑来指导并驱动整个流程，就像管弦乐队中的指挥一样。  
使用**协同(choreography)**的话，我们仅仅会告知系统中各个部分各自的职责，而把具体怎么做的细节留给它们自己，就像芭蕾舞中每个舞者都有自己的方式，同时也会响应周围其他人。

---

**例子：**  
MusicCorp中创建用户时发生了什么：
1. 在客户的积分账户中创建一条记录
2. 通过邮政系统发送一个欢迎礼包
3. 向客户发送欢迎电子邮件

![](pic/6.png)
- 如果使用编排  
  最简单的就是客户服务作为中心大脑，如果使用的是同步的请求/响应模式，甚至能知道每一步是否都成功。缺点是中心控制点承担太多职责。
  ![](pic/7.png)
- 如果使用协同  
  可以仅仅从客户服务中使用异步的方式触发一个事件，该事件名为“客户创建”。优点是显著消除耦合，缺点是看不到明显的业务流程图。需要一些额外的工作来监控流程，保证正确进行。比如，如果几分账户存在的bug导致账户没有创建成功，程序是否能够捕捉这个问题。  
  一般重量级编排的编排非常不稳定且代价高，所以更倾向协同。
  ![](pic/8.png)
- 如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以**采用异步请求加回调方式**。

## 远程过程调用
RPC允许进行一个本地调用，但事实上结构是由某个远程服务器产生的。

**RPC技术**：
- Java RMI：要求相同的技术栈，带来紧耦合。
- Thrift
- protocol buffers
- SOAP

**优点**：
- RPC的实现可以生成服务端和客户端的桩代码，从而让你快速开始编码。
- ...

**缺点**：
- 随着使用慢慢暴露一些问题。
- 技术的耦合。如RMI，客户端和服务器都一定要JVM
- 本地调用和远程调用并不相同。**RPC的核心想法是隐藏远程调用的复杂性**，但是很多RPC的实现隐藏过头，程序员很容易将其当作本地调用来用，RPC会花大量时间对负荷进行封装和解封装。
- 而且网络也会有延迟且不可靠。
- 脆弱性。如果服务端对远程函数规格说明（如添加一个创建用户的远程函数）进行修改，客户端都需要重新生成桩。如果删除了原本远程函数的某个形参，那么客户端和服务端都需要为了应用这些修改重新部署。

**RPC真的很糟糕？**
- 不要对远程调用过度抽象，以至于网络因素完全被隐藏。
- 在客户端不要隐藏我们是在做网络调用这个事实。
- 不要使用RMI。

## REST

### REST与HTTP
REST架构声明了一组对所有资源的标准方法，而HTTP恰好也定义了一组方法可供使用。而且HTTP也自带了许多功能和其HTTP生态带来的工具也给REST架构的实现带来便利。

### 超媒体作为程序状态引擎（HATEOAS）
客户端应该与服务端通过那些**指向其他资源的**链接进行交互，而这些交互有可能造成状态转移。如不需要Customer在服务端的URI，客户端根据链接导航到它想要的东西。（注：就像一个超链接）
> 我的理解：  
> 其实就是一个用户可找到位置的超链接，如获取作者信息，然后这个链接可以一直变，只要这种可找到性不变，这个URI是可以变的。

- 缺点：  
  - 客户端和服务端之间的通信次数会比较多。因为客户端需要不断的发现连接--请求---发现连接---请求

- 微服务设计的作者很喜欢这种方式。让客户端自行遍历和发现API，这需要一些投入，但是回报的时间往往比较长。

### JSON还是XML
基于HTTP的REST能够提供多种不同的响应形式。其中有JSON和XML。

- JSON
  - 优点
    - 简单，更加流行
  - 缺点
    - 没有像XML是那样使用链接来进行超媒体控制。`HAL`试图为JSON定义通用的超文本标准格式

- XML
  - 优点
    - 在工具上有很好的支持。如当只想要提取负载的某个特定部分的话，可以使用XPATH，而XPATH标准的工具相当多。如果使用JSON也有JSONPATH但是目前支持该标准的工具很有限。

### 留心过多的约定

<div align="center">
  <img src="pic/9.png">
</div>

<div align="center">
  <img src="pic/10.png">
</div>

### 基于HTTP的REST的缺点
- 基于HTTP的REST无法帮助你生成客户端的桩代码，而RPC可以。
- 性能上也可能会遇到问题。基于HTTP的REST支持不同的格式比如JSON或者二进制，所以负载相对SOAP来说更加紧凑
- 在低延迟的要求下，HTTP头的封装开销是个问题。更高效的是构建与TCP或者其他网络技术之上的协议更加高效，比如WebSocket。如果低延迟对业务来说很重要，可以考虑UDP，很多RPC框架都可以很好运用除了TCP之外的其他协议上。
- 有些RPC的实现支持高级的序列化和反序列化机制。但是对于REST这一部分需要自己做，这可能带来耦合点。

## 实现基于事件的异步协作方式
### 技术选择
- 两个部分需要考虑
  - 发布事件机制
  - 接收事件机制

- 方法
  - 一种是消息中间件：RabbitMQ，NSQ，Redis等。提供了许多功能，如记录是否被接收。
  - 另一种是HTTP传播事件：ATOM，通过他提供资源聚合的发布服务，而有很多客户端库可以消费该聚合。使用ATOM，用户需要自己追踪消息是否送达及管理轮训的工作。

- 注意
  - 在使用ATOM的时候，不要花太多时间成本在实现某些中间件已有的功能上
  - **尽量让中间件保持简单，而把业务逻辑放在自己的服务中**


### 异步架构的复杂性
- 推荐《企业集成模式》

- 需要消息的发布订阅操作
- 考虑一个非常耗时的异步请求/响应
  - 需要考虑响应返回时怎么处理
    - 是否回到发送请求的那个节点
      - 如果是，节点停止了怎么办
      - 如果不是，是否需要把信息实现存储到某个其他地方，以便于做相应的处理

### 服务即状态机
- 服务应该根据限界上下文进行划分。客户微服务应该拥有`与这个上下文中行文相关的所有逻辑`(注：我的理解就是被调用不需要在请求其他微服务，在本服务就可以解决)
- 客户服务控制了所有与客户生命周期相关的事件。当消费者想要对客户做修改时，他会向客户服务发送一个合适的请求，如果出现了在客户服务之外与其进行相关的修改的情况，那么就失去了内聚性。

<div align="center">
  <img src="pic/11.png">
</div>

### 响应式扩展
响应式扩展(Reactive extensions,Rx):可以把多个调用结果组装起来并且在此基础上执行操作
- Rx实现都在分布式系统中找到归宿
- 我可以简单的对下游服务的调用进行观察，而不需要关心他是阻塞还是非阻塞的，唯一需要做到就是等待结果并做出响应。其漂亮指出在于，可以把多个不同的调用组合起来，这样就可以更容易的对下游服务的并发调用做处理
- 当你需要做一些基于多个服务调用的操作时，可以尝试一下适合所选用技术栈的响应式扩展。


### 微服务世界中的DRY和代码重用的危险
DRY：Don't Repeat Yourself。  
- 使用DRY可能带来耦合。如果是跨服务共享代码库，那么可能引入耦合。
- 像使用日志库这样的公共代码就没什么问题，因为他们对外不可见。
- 作者经验：在微服务内部不要违反DRY，但在跨服务情况下可以适当违反DRY。

#### 客户端库
看不太懂，介绍了AWS的客户端库和Netflix

### 按引用访问
有时候获取一个资源，但是这个资源可能存在一定时效性，持有越久失效可能性越高。比如，获取用户信息。使用本地副本没有问题，但是要知道该副本是否已经失效。所以`确保同时持有一个指向原始资源的引用`（注：我觉得可以存一个hash），这样在需要时就可以对本地副本进行更新。

- 如果在获取资源的同时，可以获取资源的有效性时间，那么可以进行缓存，减小服务的负载。避免频繁的查询。


## 版本管理
### 尽可能推迟
- 减小破坏性修改影响最好的办法就是尽量不要这么做。
- 另一个延迟破坏性修改的关键是`鼓励客户端的正确行为，避免过早的和服务端的数据绑定的太紧`
  - 比如我现在返回三个字段，如果我对这个api进行修改，返回四个，现在如果客户端进行了很强的绑定就会报错。
  - 一些强类型语言会使用一些绑定技术，这种技术会将所有字段进行自动绑定，无论消费者是否需要。
  - 解决：使用XPath来从中提取出想要的信息。这样字段的位置就可以更加灵活，这就是`容错性读取器`
  - 客户端尽可能灵活的消费服务响应这一点符合`Postel法则`(鲁棒性法则)。该法则认为`每个模块都应该”宽进严出“即对自己发送的东西要严格，对接收的东西要宽容`

### 及早发现破坏性修改
- 破坏性修改难免出现，推荐使用`消费者驱动的契约`来及早定位问题。
- 如果支持多种不同的客户端库，最好针对最新服务对所有客户端运行测试。一旦意识到，你可能会对某一个消费者造成破坏，那么需要和他的开发者进行协商。


### 使用语义化的版本管理
- 语义化版本管理
  - 功能：使得客户端能够仅仅通过查看版本号，就知道他是否能够与之集成。
  - 格式：MAJOR.MINOR.PATCH
    - MAJOR：改变意味着包含向后不兼容的修改。
    - MINOR：改变意味着包含新功能添加。
    - PATCH：改变意味着对已有功能的缺陷修复。


### 不同版本接口共存
- 在同一个服务上部署新老接口
- 当老版本没人用了，就对API进行收缩
<div align="center">
  <img src="pic/12.png">
</div>

<div align="center">
  <img src="pic/13.png">
</div>

- HTTP
  - 请求中添加版本信息。
  - 也可以将其添加在URI中。

- RPC(比较复杂)
  - protocol buffer

### 同时使用多个版本服务
- 在进行蓝绿板书或者金丝雀发布的时候，会存在两个服务的情况。
- 但是如果长时间存在，是一种不推荐的手段。因为有两个版本，一个修改需要修改另外一个。
<div align="center">
  <img src="pic/14.png">
</div>

# 部署
CI：持续集成（CONTINUOUS INTEGRATION）
- 在CI环境中，开发人员将会频繁地向主干提交代码。这些新提交的代码在最终合并到主干前，需要经过编译和自动化测试流进行验证。