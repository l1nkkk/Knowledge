- [三大范式](#三大范式)
- [锁](#锁)
- [索引](#索引)
  - [B-Tree与B+树](#b-tree与b树)
  - [哈希索引](#哈希索引)
  - [聚集索引和非聚集索引（稀疏索引）](#聚集索引和非聚集索引稀疏索引)
  - [覆盖索引](#覆盖索引)
- [事务](#事务)
  - [简述事务](#简述事务)
  - [事务隔离级别](#事务隔离级别)
  - [脏读、脏写、读倾斜（不可重复读）、更新丢失、写倾斜、幻读](#脏读脏写读倾斜不可重复读更新丢失写倾斜幻读)
  - [乐观锁如何保持一致性](#乐观锁如何保持一致性)
- [分布式](#分布式)
  - [两阶段提交](#两阶段提交)
  - [分布式id生成方法](#分布式id生成方法)
- [Mysql](#mysql)
  - [Mysql架构](#mysql架构)
    - [服务层](#服务层)
    - [存储引擎层](#存储引擎层)
  - [InnoDB 和 MyISAM](#innodb-和-myisam)
    - [InnoDB](#innodb)
    - [MyISAM](#myisam)
  - [Mysql有哪些常见索引类型](#mysql有哪些常见索引类型)
  - [自适应Hash索引](#自适应hash索引)
  - [InnoDB的二级索引](#innodb的二级索引)
  - [联合索引和最左匹配原则](#联合索引和最左匹配原则)
  - [为什么数据库不用红黑树用B+树](#为什么数据库不用红黑树用b树)
  - [explain](#explain)
  - [MySQL优化流程](#mysql优化流程)
  - [日志](#日志)
    - [binlog](#binlog)
    - [redo log](#redo-log)
    - [undo log](#undo-log)
  - [MySQL主从复制](#mysql主从复制)
  - [只靠binlog可以支持数据库崩溃恢复吗](#只靠binlog可以支持数据库崩溃恢复吗)
  - [触发器](#触发器)
  - [增删改查](#增删改查)
  - [delte和truncate区别](#delte和truncate区别)
  - [char和varchar区别](#char和varchar区别)
  - [delete和truncate区别](#delete和truncate区别)
  - [InnoDB可重复读是否存在幻读问题](#innodb可重复读是否存在幻读问题)
  - [crash-safe能力](#crash-safe能力)
  - [WAL](#wal)
  - [mysql为什么要用自增id作为主键](#mysql为什么要用自增id作为主键)
# 三大范式
> https://segmentfault.com/a/1190000013695030

- 可能存在的问题：
  - 从 冗余、增删改查 去考虑

- 第一范式：表中字段值是**原子的**
  - 表：字段1、 字段2(字段2.1、字段2.2)、字段3 ......
  - 如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是；



- 第二范式：唯一性。非主键字段完全依赖主键，而不是部分依赖。（第二范式针对联合主键的情况）
  - 表：学号、课程号、姓名、学分;
    - 学分依赖课程号，姓名依赖与学号
  - 正确做法
    ```
    学生：Student(学号, 姓名)；
    课程：Course(课程号, 学分)；
    选课关系：StudentCourse(学号, 课程号, 成绩)。
    ```



- 第三范式：不存在传递依赖
  - 表: 学号, 姓名, 年龄, 学院名称, 学院电话.
    - 存在依赖传递: (学号) → (学生)→(所在学院) → (学院电话)
  - 正确做法：
  ```
  学生：(学号, 姓名, 年龄, 所在学院)；

  学院：(学院, 电话)。
  ```

- 反范式化
  - 适当的违反下范式，空间换时间




# 锁
- 共享锁：读锁，共享模式。
  - 需等待写锁释放
- 排它锁：写锁，独占模式。
  - 需等待所有读锁释放
- 表级锁
- 行锁
- 区间范围锁（间隙锁）：
- Next-key Lock
- 乐观锁，悲观锁

# 索引
- 什么是索引：一种加快查找的特殊的数据结构。
- 目的：加快查询效率

- 什么时候需要创建索引：
  - 频繁作为查询条件
  - 查询中该字段需要排序
  - 查询中需要统计或者分组或者范围查询
- 什么时候索引失效：
  - 不满足最左匹配原则
  - 查询条件有or
    - 使用or，又想索引生效，只能将or条件中的每个列都加上索引
  - where 条件语句对索引列有数学运算或函数

## B-Tree与B+树
- B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字值，且右子节点的关键字值大于或等于该节点关键字值。

- B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。

- B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。

## 哈希索引
- 哈希算法+大区间
- 不支持范围查询
- 不支持部分索引列查找
- 一般都是在内存，放在磁盘大量随机读

## 聚集索引和非聚集索引（稀疏索引）
- 聚集索引：索引中直接保存行数据
- 非聚集索引：索引中值保存部分数据

## 覆盖索引
- 覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值。

# 事务
## 简述事务
- 目的：简化应用程序代码
- 描述：事务内的语句要么全部执行成功，要么全部执行失败
- ACID
  - 原子性：可中止
  - 一致性：维持某恒等关系
  - 隔离性：多个事务互相隔离，不能交叉
  - 持久性：持久化存储

## 事务隔离级别
- **读未提交**：一个事务还没提交，它做的变更就能被别的事务看到。
- **读提交**：一个事务提交后，它做的变更才能被别的事务看到。
- **可重复读（快照级别隔离）**： 一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。
- **串行化**： 对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。



## 脏读、脏写、读倾斜（不可重复读）、更新丢失、写倾斜、幻读
- 脏读：当前事务读到了其他事务尚未提交的写入。
- 脏写：当前事务覆盖了其他事务尚尚未提交的写入。
- 读倾斜（不可重复读）：一个事务的两次读取中，发现一致性似乎被破坏。
- 写倾斜：
  - 发生情况：查询---判断---修改（可能不是这个顺序），其中修改会影响判断
- 更新丢失：
  - 发生情况：查询---修改（基于查询结果，修改数据库中的值）
- 幻读

## 乐观锁如何保持一致性
# 分布式
## 两阶段提交
## 分布式id生成方法
- snowflake算法：利用**时间戳，机器id，当前数据库自增id**进行拼接，生成的新的分布式id。

# Mysql
## Mysql架构 
- https://segmentfault.com/a/1190000038844134
- https://juejin.cn/post/7011276065792327688

<div align="center" style="zoom:90%"><img src="pic/3-1.png"></div>

### 服务层
- 主要包括：连接器、分析器、优化器、执行器、查询缓存
> 连接池
- 负责用户连接和鉴权

> 查询缓存
- 结构：一个key-value，key为sql语句，value为返回结果
- 建议不用，可能弊大于利。因为只要这里有一行修改，缓存全部都要删除。
  - 除非缓存的表是静态的，否则对于更新压力大的数据，只会影响性能
- 注：MySQL 8.0版本直接将查询缓存的整块功能删掉了
> 解析器
- 词法分析：分词
- 语法分析：是否满足MySQL语法

> 优化器
- 决定使用哪些索引。决定多个join时的顺序等等

> 执行器
- 实际执行sql的地方
  - 先鉴权
  - 再执行

### 存储引擎层
- 数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。


## InnoDB 和 MyISAM
- https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#innodb
### InnoDB
- 5.5之后默认的存储引擎
- 事务：实现了四个标准的隔离级别，默认级别是**可重复读**。可重复读隔离级别下，通过多版本并发控制 **（MVCC）+ Next-Key Locking 防止幻读**。
- 锁：行锁、表锁、 Next-Key Locking
- 索引：主索引是聚集索引
- 优化：做了很多优化，如自适应hash、可预测读等
- 备份：可以在线热备份，MVCC的功劳吧

### MyISAM
- 5.5之后=前默认的存储引擎
- 事务：不支持
- 锁：只支持表锁
  - 读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在**表有读取操作的同时，也可以往表中插入新的记录**，这被称为并发插入（CONCURRENT INSERT）
- 外键：不支持外键
- 特性：MyISAM 支持**压缩表和空间数据索引**
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB **高**很多，而且恢复的速度也更**慢**。



## Mysql有哪些常见索引类型
- 数据结构角度：B-Tree索引 哈希索引 R-Tree索引 全文索引
- 物理存储角度：
  - 主键索引（聚集索引）：叶子节点存的是整行的数据 
  - 二级索引：叶子节点为主键的值


## 自适应Hash索引
- InnoDB对于**频繁使用的某些索引值**，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。

## InnoDB的二级索引
- 索引中的数据为主键。所以需要索引两次，一次二级索引中进行，找到主键，再到聚集索引中去找到数据。也称**回表查询**

## 联合索引和最左匹配原则
- https://segmentfault.com/a/1190000015416513
- **在mysql建立联合索引时会遵循最左前缀匹配的原则**，即最左优先。**在检索数据时从联合索引的最左边开始匹配**
> eg
- 对列col1、列col2和列col3建一个联合索引
  - 联合索引 test_col1_col2_col3 实际建立了`(col1)、(col1,col2)、(col,col2,col3)`三个索引
```
KEY test_col1_col2_col3 on test(col1,col2,col3);
```
- 下面这个查询语句执行时会**依照最左前缀匹配原则**，检索时会使用索引·进行数据匹配
```
SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
```
> 为什么要使用联合索引
- 减少开销。建一个联合索引`(col1,col2,col3)`，实际相当于建了`(col1),(col1,col2),(col1,col2,col3)`三个索引。
- 覆盖索引。
  - `select col1,col2,col3 from test where col1=1 and col2=2`，不用回表
- 效率高。索引列越多，通过索引筛选出的数据越少


## 为什么数据库不用红黑树用B+树
- 红黑树的出度为 2。B+Tree 拥有更大的出度，IO次数较少，检索效率会更高。
- 并且B+树的设计使每个节点比B树存更多信息，减少IO随机读。


## explain
- 分析sql语句的执行情况
  - type：表示连接类型
  - key：显示MySQL实际决定使用的键
  - key_len：显示MySQL决定使用的键长度，长度越短越好
  - rows : 扫描的行数
  - Extra：额外信息

> type，从好到差的类型排序为
```
system：系统表，数据已经加载到内存里。
const：常量连接，通过索引一次就找到。
eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。
ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。
range：范围扫描，在索引上扫码特定范围内的值。
index：索引树扫描，扫描索引上的全部数据。
all：全表扫描
```

## MySQL优化流程
- 分析方式：
  - 通过慢日志定位执行较慢的SQL语句
  - 利用explain对这些关键字段进行分析

- 优化数据访问
  - **只返回必要的列**：最好不要使用 SELECT * 语句
  - **只返回必要的行**：使用 LIMIT 语句来限制返回的数据
  - **使用缓存**：**对于更新较少的表**

- 重构查询方式
  - **切分大型更新**：一次写很多，可能需要锁很多数据，这个事务很长，影响其他的业务，如以下sql
    - `DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);`
    - 解决
      ```sql
          rows_affected = 0
          do {
              rows_affected = do_query(
              "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
          } while rows_affected > 0
      ```
  - **分解大连接查询**：将一个大连接查询分解成对每一个表进行一次单表查询，然后**在应用程序中进行关联**，好处如下
    - 缓存更加高效
    - 减少锁竞争
    - 数据库压力不会太大

## 日志
- 参考：https://jishuin.proginn.com/p/763bfbd56537
- binlog
- redo log
- undo log
### binlog
- 记录数据库表结构和表数据变更的二进制日志，与存储引擎解耦
- 作用
  - 主从复制
  - 数据恢复
- 记录时间：在提交事务的时候
<div align="center" style="zoom:90%"><img src="pic/3-4.webp"></div>


### redo log
- 存储引擎相关（MyISAM没有）。针对的是事务的恢复。当内存数据刷新到磁盘中，redo log的数据就失效了
- redo log file记录着xxx页做了xxx修改，所以即使mysql发生宕机，也可以通过redo log进行数据恢复
  - 更细粒度的记录，与存储引擎的存储设计有关，提供更强持久化能力。
  - MyISAM持久化能力不如InnoDB，容易出错。
<div align="center" style="zoom:90%"><img src="pic/3-3.webp"></div>

- 记录时间：在内存修改后
- 删除时间：刷到磁盘后

> binlog和redo log都可以数据恢复，有什么区别？
- redo log：恢复的是，数据在缓存更新完，还没刷到磁盘的情况
- binlog存储所有数据变更情况
- 假如不小心整个数据库的数据被删除了，只能通过binlog恢复，因为当内存数据刷新到磁盘中，redo log的数据就失效了

### undo log
- 存储引擎相关（MyISAM没有）。主要用于回滚。
- `undo log`主要存储的是数据的逻辑变化日志，比如说我们要 `insert` 一条数据，那么`undo log`就会生成一条对应的 `delete` 日志。
- **undo log另一个作用是实现多版本控制(MVCC)**，**undo记录中包含了记录更改前的镜像**，如果更改数据的事务未提交，对于隔离级别大于等于read commit的事务而言，不应该返回更改后数据，而**应该返回老版本的数据**。

## MySQL主从复制
- 主要涉及三个线程：**binlog 线程、I/O 线程和 SQL 线程**
  - binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
  - I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
  - SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
<div align="center" style="zoom:90%"><img src="pic/3-2.png"></div>



## 只靠binlog可以支持数据库崩溃恢复吗
- 考到算我输

## 触发器
- 监视某种情况，并触发某种操作
- 当触发器所在表上出现指定事件(insert/update/delete)时，可指定时间(after/before)执行特定事件(insert/update/delete)


## 增删改查
```sql
增：INSERT INTO 表名（字段名1，字段名2，…）VALUES（值1，值2，…）

删：DELETE FROM 表名 [WHERE 条件表达式] TRUNCTE [TABLE ] 表名（删除整张表数据）

改：UPDATE 表名 SET 字段名1=值1，[ ，字段名2=值2，…] [ WHERE 条件表达式 ]

查：SELECT 字段名1，字段名2，… FROM 表名 [ WHERE 条件表达式 ]
```

## delte和truncate区别

delete是数据操纵语言（DML），其按行删除，支持where语句，执行操作采用行锁，执行操作时会将该操作记录在redo和undo中，因此支持回滚。

truncate是数据定义语言（DDL），其操作隐式提交，不支持回滚，不支持where，删除时采用表级锁进行删除。

## char和varchar区别
- char：定长。效率较高
- varchar：不定长。灵活
  - 底层存储：字段开头包含一个变长字段的实际长度，后面存储的是真实字符

## delete和truncate区别

delete是数据操纵语言（**DML**），其按行删除，支持where语句，执行操作采用行锁，执行操作时会将该操作记录在redo和undo中，因此支持回滚。

truncate是数据定义语言（**DDL**），其操作隐式提交，不支持回滚，不支持where，删除时采用表级锁进行删除。

## InnoDB可重复读是否存在幻读问题

不存在，InnoDB通过引入间隙锁+行锁（next key lock）的方式，解决了幻读问题


## crash-safe能力
- InnoDB通过redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe

## WAL
- 目的
  - 持久性
  - 效率
- WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前，会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I/O访问，涉及磁盘随机I/O访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。

## mysql为什么要用自增id作为主键
- 为了效率。
  - 如果是自增的，**页满了之后添加新页就好了**。那么可以避免因为主键索引因为插入而分页且拷贝一部分的过程，