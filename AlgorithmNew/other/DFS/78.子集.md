> 难度：简单
- 法1：dfs
- 法2：数学归纳法

> 题目
##  dfs
```
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]


示例 2：
输入：nums = [0]
输出：[[],[0]]
```

> 代码

```cpp
class Solution {
public:
    vector<vector<int>> res;
    list<int> tempRes;
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums,0);
        return res;
    }
    void dfs(vector<int>& nums, int d){
        if(d == nums.size()){
            res.push_back(vector<int>(tempRes.begin(),tempRes.end()));
            return;
        }
        // 不选
        dfs(nums, d+1);
        // 选
        tempRes.push_back(nums[d]);
        dfs(nums, d+1);
        tempRes.pop_back();
    }
};
```

```
执行用时：4 ms, 在所有 C++ 提交中击败了47.49%的用户
内存消耗：13.5 MB, 在所有 C++ 提交中击败了5.81%的用户
```

## 数学归纳

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        if(nums.empty()){
            return  {{}};
        }
        int n = nums.back();
        nums.pop_back();
        auto res = subsets(nums);
        int size = res.size();

        for(int i = 0; i < size; ++i){
            res.push_back(res[i]);
            res.back().push_back(n);
        }
        return res;
    }
};
```
```
执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗：7.1 MB, 在所有 C++ 提交中击败了24.38%的用户
```