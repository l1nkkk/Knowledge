- [](#)
- [快速排序](#快速排序)
- [归并排序](#归并排序)

# 概述
# 冒泡排序
- https://www.cnblogs.com/chengxiao/p/6103002.html
```cpp
class BubbleSort{
public:
    void sort(vector<int>& nums){
        for(int i = 0; i < nums.size()-1; ++i){
            for(int j = 0; j < nums.size()-i-1; ++j){
                if(nums[j] > nums[j+1]){
                    nums[j] ^= nums[j+1];
                    nums[j+1] ^= nums[j];
                    nums[j] ^= nums[j+1];
                }
            }
        }
    }
};
```

# 选择排序
- https://www.cnblogs.com/chengxiao/p/6103002.html
```cpp
class SelectSort{
public:
    void sort(vector<int> &nums){
        for(int i = 0; i < nums.size()-1; ++i){
            int maxIdx = 0;
            for(int j = 1; j < nums.size()-i;++j){
                if(nums[j]>nums[maxIdx])
                    maxIdx = j;
            }
            swap(nums[maxIdx], nums[nums.size()-i-1]);
        }
    }
};

```
# 插入排序
- https://www.cnblogs.com/chengxiao/p/6103002.html

```cpp
class InsertSort{
public:
    void sort(vector<int>&nums){
        for(int i = 1; i < nums.size(); ++i){
            for(int j = i-1; j >= 0; --j){
                if(nums[j] < nums[j+1])
                    break;
                swap(nums[j+1],nums[j]);
            }
        }
    }
};

```

# 快速排序
- https://www.cnblogs.com/penghuwan/p/7883076.html
  - 图片，理解比较好
- https://blog.csdn.net/liuchen1206/article/details/6954074
  - 代码简洁，逻辑性强

- 前序遍历
```cpp
class QuickSort{
public:
    int partition(vector<int>& nums, int lo, int hi){
        int x = nums[lo];
        while(lo < hi){
            while(lo < hi && nums[hi] >= x){
                --hi;
            }
            if(lo == hi)
                break;
            nums[lo++] = nums[hi];

            while(lo < hi && nums[lo] < x){
                ++lo;
            }
            if(lo == hi)
                break;
            nums[hi++] = nums[lo];
        }
        nums[lo] = x;
        return lo;
    }
    void sort(vector<int>& nums, int lo, int hi){
        // 递归base case
        if(lo >= hi) return;
        auto p = partition(nums,lo,hi);
        sort(nums, lo, p-1);// 左子树
        sort(nums, p+1, hi);// 右子树
    }
};
```

# 归并排序
- https://www.cnblogs.com/chengxiao/p/6194356.html
  - 图不错，代码不怎么样
- https://zhuanlan.zhihu.com/p/124356219
  - 代码花里胡哨
- 后序遍历

```cpp
class MergeSort{
public:
    // 左闭右闭
    void sort(vector<int>& nums, int lo, int hi, vector<int> &output){
        if(lo >= hi) return;
        int mid = (lo+hi)/2;
        // 注意，这里如果变成【lo,mid-1】和【mid，hi】的话，会在sort死循环
        sort(nums, lo, mid, output);
        sort(nums, mid+1, hi, output);
        merge(nums, lo, mid,mid+1, hi, output);
        return;
    }
    void merge(vector<int>& nums, int lstart, int lend, int rstart, int rend, vector<int> &output){
        int start = lstart;
        int end = rend;
        int pos = lstart;
        while(lstart <= lend && rstart <= rend){
            if(nums[lstart] < nums[rstart]){
                output[pos++] = nums[lstart++];
            }else{
                output[pos++] = nums[rstart++];
            }
        }
        while(lstart <= lend){
            output[pos++] = nums[lstart++];
        }
        while(rstart <= rend){
            output[pos++] = nums[rstart++];
        }

        // 最后记得更新，更新到原始的数组里，方便后面的归并
        while(start <= end){
            nums[start] = output[start];
            start++;
        }
    }
};
```