- [概述](#概述)
- [冒泡排序](#冒泡排序)
- [选择排序](#选择排序)
- [插入排序](#插入排序)
- [快速排序](#快速排序)
- [归并排序](#归并排序)
- [堆排序](#堆排序)



- 非稳定排序：选择、快排、堆排序、希尔排序
  - https://zhuanlan.zhihu.com/p/116046849
# 概述
# 冒泡排序
- https://www.cnblogs.com/chengxiao/p/6103002.html
```cpp
class BubbleSort{
public:
    void sort(vector<int>& nums){
        for(int i = 0; i < nums.size()-1; ++i){
            for(int j = 0; j < nums.size()-i-1; ++j){
                if(nums[j] > nums[j+1]){
                    nums[j] ^= nums[j+1];
                    nums[j+1] ^= nums[j];
                    nums[j] ^= nums[j+1];
                }
            }
        }
    }
};
```

# 选择排序
- https://www.cnblogs.com/chengxiao/p/6103002.html
```cpp
class SelectSort{
public:
    void sort(vector<int> &nums){
        for(int i = 0; i < nums.size()-1; ++i){
            int maxIdx = 0;
            for(int j = 1; j < nums.size()-i;++j){
                if(nums[j]>nums[maxIdx])
                    maxIdx = j;
            }
            swap(nums[maxIdx], nums[nums.size()-i-1]);
        }
    }
};

```
# 插入排序
- https://www.cnblogs.com/chengxiao/p/6103002.html

```cpp
class InsertSort{
public:
    void sort(vector<int> &nums){
        for(int i = 1; i < nums.size(); ++i){
            for(int j = i; j > 0; --j){
                if(nums[j-1] > nums[j]){
                    swap(nums[j-1], nums[j]);
                }
            }
        }
    }
};

```

# 快速排序
- https://www.cnblogs.com/penghuwan/p/7883076.html
  - 图片，理解比较好
- https://blog.csdn.net/liuchen1206/article/details/6954074
  - 代码简洁，逻辑性强

- 前序遍历
```cpp
class QuickSort{
public:
    int partition(vector<int>& nums, int lo, int hi){
        int x = nums[lo];
        while(lo < hi){
            while(lo < hi && nums[hi] >= x){
                --hi;
            }
            if(lo == hi)
                break;
            nums[lo++] = nums[hi];

            while(lo < hi && nums[lo] < x){
                ++lo;
            }
            if(lo == hi)
                break;
            nums[hi--] = nums[lo];
        }
        nums[lo] = x;
        return lo;
    }
    void sort(vector<int>& nums, int lo, int hi){
        // 递归base case
        if(lo >= hi) return;
        auto p = partition(nums,lo,hi);
        sort(nums, lo, p-1);// 左子树
        sort(nums, p+1, hi);// 右子树
    }
};
```

# 归并排序
- https://www.cnblogs.com/chengxiao/p/6194356.html
  - 图不错，代码不怎么样
- https://zhuanlan.zhihu.com/p/124356219
  - 代码花里胡哨
- **后序遍历**

```cpp
class MergeSort{
public:
    // 左闭右闭
    void sort(vector<int>& nums, int lo, int hi, vector<int> &output){
        if(lo >= hi) return;
        int mid = (lo+hi)/2;
        // 注意，这里如果变成【lo,mid-1】和【mid，hi】的话，会在sort死循环
        sort(nums, lo, mid, output);
        sort(nums, mid+1, hi, output);
        merge(nums, lo, mid,mid+1, hi, output);
        return;
    }
    void merge(vector<int>& nums, int lstart, int lend, int rstart, int rend, vector<int> &output){
        int start = lstart;
        int end = rend;
        int pos = lstart;
        while(lstart <= lend && rstart <= rend){
            if(nums[lstart] < nums[rstart]){
                output[pos++] = nums[lstart++];
            }else{
                output[pos++] = nums[rstart++];
            }
        }
        while(lstart <= lend){
            output[pos++] = nums[lstart++];
        }
        while(rstart <= rend){
            output[pos++] = nums[rstart++];
        }

        // 最后记得更新，更新到原始的数组里，方便后面的归并
        while(start <= end){
            nums[start] = output[start];
            start++;
        }
    }
};
```

# 堆排序
- 参考: https://labuladong.github.io/algo/2/22/63/er-cha-dui-xiang-jie-shi-xian-you-xian-ji-dui-lie
- 参考: https://www.cnblogs.com/chengxiao/p/6129630.html



- 最大堆还是最小堆：
  - 最大堆的性质是：**每个节点都大于等于它的两个子节点**.
  - 最小堆的性质是：**每个节点都小于等于它的两个子节点**
  - 对于排序：
    - 升序----使用大顶堆
    - 降序----使用小顶堆
  - 优先队列：
    - 出最大——大顶堆
    - 出最小——小顶堆
- 把握两个操作：swim(上浮) & sink(下沉)

- 排序（升序）：
  - 从最后一个不是叶子节点开始到根节点，执行下沉，形成最大堆
  - 把最大的删除（即放最后），用到了下沉
  - 删除到最后形成由小到大的数组。
- 优先队列：
  - 删除时，将数和最后的交换，然后下沉
  - 插入时，将数放在最后，然后上浮

```cpp
class headSort{
public:
    headSort(vector<int>& anums):nums(anums){
        END = anums.size();
    }
    void sort(){
        // 创最大堆
        createBigHeap();
        // 将顶和最后交换，然后将顶下层
        while(END > 0){
            swap(nums[--END], nums[0]);
            sink(0);
        }
    }

private:
    void createBigHeap(){
        // 先找到第一个非叶子节点
        int node = (END-1)/2;
        while(node >= 0){
            sink(node);
            --node;
        }
    }

private:
    // 下沉
    void sink(int k){
        // 先试探left，因为right可能不存在
        while(left(k) < END){
            int older = left(k);
            if(right(k) < END && nums[older] < nums[right(k)])
                older = right(k);
            if(nums[k] >= nums[older]) break;
            swap(nums[k],nums[older]);
            k = older;
        }
    }

    // 上浮
    void swim(int k){
        while(k > 0 && nums[parent(k)] < nums[k]){
            swap(nums[parent(k)], nums[k]);
            k = parent(k);
        }
    }

    inline int parent(int k){
        if(k == 0) return -1;
        return (k-1)/2;
    }
    inline int left(int k){
        return k*2+1;
    }
    inline int right(int k){
        return k*2+2;
    }

    vector<int>& nums;
    int END;
};

void testHeapSort(){
    vector<int> input{4,1,5,9,2,6,5,6,1,8,0,7};
    auto s = headSort(input);
    s.sort();
    for(auto &a : input){
        cout << a << " ";
    }

}
```