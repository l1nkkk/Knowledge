> 难度：简单
- 法1：按数组插入排序的思想去做（从后到前，前一个和后一个交换）
  - 数组为什么要这样：因为数组没办法在中间o(1)插入，我这样做就相当于把链表特性消除了。
- 法2：直接找到目标点，直接插入

> 代码
- 法1
```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        stack<ListNode *> stk;
        ListNode* dumpHead = new ListNode(0,head);
        stk.push(dumpHead);
        stk.push(head);
        ListNode *next = head->next;
        while(next){
            ListNode *cur = next;
            next = next->next;
            while(stk.top()!=dumpHead && cur->val < stk.top()->val){
                auto pre = stk.top();
                stk.pop();
                stk.top()->next = cur;
                pre->next = cur->next;
                cur->next = pre;
            }
            // 重新入栈
            while(cur != next){
                stk.push(cur);
                cur = cur->next;
            }
        }
        return dumpHead->next;
    }
};
```
```
执行用时：792 ms, 在所有 C++ 提交中击败了5.16%的用户
内存消耗：157.9 MB, 在所有 C++ 提交中击败了5.03%的用户
```

- 法2

```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* dumpHead = new ListNode(0,head);

        ListNode *cur = head->next;
        ListNode *lastSorted = head; // 排完序的最后一个节点
        while(cur){
            // 优化点
            if(lastSorted->val <= cur->val){
                lastSorted = lastSorted->next;
            }
            else{
                ListNode *it = dumpHead->next;
                ListNode *pre = dumpHead;
                while(it != cur && it->val < cur->val){
                    it = it->next;
                    pre = pre->next;
                }
                pre->next = cur;
                lastSorted->next = cur->next;
                cur->next = it;
            }
            cur = lastSorted->next;
        }
        return dumpHead->next;
    }
};
```
```
执行用时：16 ms, 在所有 C++ 提交中击败了81.47%的用户
内存消耗：9.3 MB, 在所有 C++ 提交中击败了60.58%的用户
```