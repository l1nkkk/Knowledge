
- https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/dui-lie-shi-xian-zhan-zhan-shi-xian-dui-lie

- 用队列实现栈是没啥亮点的问题，但是**用双栈实现队列是值得学习的**
# 232. 用栈实现队列
- https://leetcode-cn.com/problems/implement-queue-using-stacks/

- 用两个栈，知道思路就很容易实现

```cpp

class MyQueue {
public:
    // st1负责push，st2负责pop
    stack<int> st1,st2;
    /** Initialize your data structure here. */
    MyQueue() {

    }

    /** Push element x to the back of queue. */
    void push(int x) {
        st1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        auto rtn = peek();
        st2.pop();
        return rtn;
    }

    /** Get the front element. */
    int peek() {
        if(st2.empty()){
            while(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }
        return st2.top();
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return st1.empty() && st2.empty();
    }
};

```


# 225. 用队列实现栈
- 使用了一个变量来记录栈顶

```cpp
class MyStack {
public:
    queue<int> que;
    int topElem;
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
        topElem = x;    // 注意
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int sz = que.size();
        for(int i = 0; i < sz-1; ++i){
            if(i == sz-2) topElem = que.front(); // 注意
            que.push(que.front());
            que.pop();
        }
        int rnt = que.front();
        que.pop();
        return rnt;
    }

    /** Get the top element. */
    int top() {
        return topElem;
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};

```