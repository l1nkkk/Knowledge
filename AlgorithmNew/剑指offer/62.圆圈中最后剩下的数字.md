> 难度：中等
- 参考：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/javajie-jue-yue-se-fu-huan-wen-ti-gao-su-ni-wei-sh/

<div align="center" style="zoom:60%"><img src="./pic/62-2.png"></div>

- 思路：因为数组环是有序的，**只要我知道 最后一个剩下的数 在初始的时候是在哪个位置，问题就解决了**
  - 初始：一共 n 个数， 每次删除第 m 个
  - 重点：最后的时候，求得的数所在的位置为 0，其位置记为res。
  - 反推上一轮的位置（如上图第四轮），res = （res + m）% x<2>。(其中x表示第四轮时还剩多少个数)
  - 迭代 n-1 次，得到结果


> 题目
<div align="center" style="zoom:60%"><img src="./pic/62-1.png"></div>


> 代码
```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int i = 1;
        int res = 0;
        // 迭代 n-1次
        while( i < n ){
            res = (res + m)%(++i);
        }
        return res;
    }
};
```