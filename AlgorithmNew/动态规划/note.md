
> 参考1：https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye/dong-tai-gui-hua-xiang-jie-jin-jie    
> 

# 概述
- **一般形式**：求最值，如最长递增子序列呀，最小编辑距离等等
- **核心问题**：穷举（特别的穷举）
- **特点（动态规划三要素）**：
  - 存在 **「重叠子问题」**
  - 具备 **「最优子结构」**：通过子问题的最值得到原问题的最值，**子问题间必须互相独立**
  - 存在 **「状态转移方程」**：只有列出正确的「状态转移方程」，**才能正确地穷举**


- **递归算法的时间复杂度**：就是用子问题个数乘以解决一个子问题需要的时间。

- **自顶向下**：一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 **base case**，然后逐层返回答案，这就叫 **「自顶向下」**。
- **自底向上**：从问题规模最小的  **base case** f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，**这就是动态规划的思路**，`这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算`。


## 状态转移方程
- **写出状态转移方程是最困难的**，以下是思考状态转移方程的思维框架：
  - 明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
- 框架代码：
```py
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```
- 列出「状态转移方程」的重要性，它是**解决问题的核心**。而且很容易发现，**其实状态转移方程直接代表着暴力解法**。
  - 通过状态转移方程，写出暴力的代码
  - 剩下的也就是优化递归树，消除重叠子问题而已。

# 例子
## 斐波那契数列
- 「最优子结构」没有涉及，不是严格的动态规划，但是很好的说明了消除重叠子问题的方法。
- 改变过程：暴力 -> (画出递归树，时间复杂度o(2^n)，发现重叠子结构) -> 备忘录 -> (时间复杂度o(n),发现是自顶向下(递归)) -> 自底向上 -> (时间复杂度o(n),已从递归变循环，空间复杂度略高，且每次只用后两个记录)-> 状态压缩

<div align="center" style="zoom:60%"><img src="./pic/2.png"></div>

## 凑零钱（重点）
### 最优子结构
为什么说它符合**最优子结构**呢？比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就可能是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。


### 确定状态转移方程
1. **确定 base case**，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
2. **确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以**唯一的「状态」就是目标金额 amount**。
3. **确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
4. **明确 dp 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：
   - dp(n) 的定义：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。

<div align="center" style="zoom:60%"><img src="./pic/1.png"></div>