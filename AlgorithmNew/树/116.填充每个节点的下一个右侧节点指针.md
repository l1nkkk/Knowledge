> 难度：中等
- 思路：难度主要是在如何把题目的要求细化成每个节点需要做的事情
  - 讲解：https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/er-cha-shu-xi-lie-1
  - 增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：

> 题目
- 重点：完美二叉树
```
给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

```
<div align="center" style="zoom:60%"><img src="./pic/116-1.png"></div>

> 代码

```cpp
//
// Created by l1nkkk on 2021/7/13.
//
#include <iostream>
using namespace std;

namespace leetcode116{
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
            : val(_val), left(_left), right(_right), next(_next) {}
};
Node* init(){
    Node* head = new Node(1);
    head->left = new Node(2);
    head->right = new Node(3);

    head->left->left = new Node(4);
    head->left->right = new Node(5);
    head->right->left = new Node(6);
    head->right->right = new Node(7);
}
class Solution {
public:
    // 定义：将left和right连接起来
    void connectTwoNode(Node* node1, Node* node2){
        if(node1 == nullptr || node2 == nullptr)
            return;
        node1->next = node2;

        connectTwoNode(node1->left, node1->right);
        connectTwoNode(node2->left, node2->right);
        // 跨越父节点的两个表兄弟节点
        connectTwoNode(node1->right, node2->left);
    }
    Node* connect(Node* root) {
        if(root == nullptr)
            return nullptr;
        connectTwoNode(root->left, root->right);
        return root;
    }
};
}
```

```
执行用时：20 ms, 在所有 C++ 提交中击败了88.66%的用户
内存消耗：16.2 MB, 在所有 C++ 提交中击败了97.94%的用户
```