> 难度：中等

1. 穷举 root 节点的所有可能。
2. 递归构造出左右子树的所有合法 BST。
3. 给 root 节点穷举所有左右子树的组合。


> 题目
<div align="center" style="zoom:0%"><img src="./pic/95-1.png"></div>

> 代码

```cpp
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return generateTrees(1, n);
    }
    // 1.选定根 2.递归左右子树 3.和根合并
    vector<TreeNode*> generateTrees(int lo, int hi) {
        vector<TreeNode*> rtn;
        if( lo > hi) return rtn;
        for(int i = lo; i <= hi; ++i){
            // 选定根i

            // 递归左右
            auto leftRes = generateTrees(lo, i-1);
            auto rightRes = generateTrees(i+1, hi);

            // 合并
            if(leftRes.size() == 0 && rightRes.size() == 0){
                auto root = new TreeNode(i);
                rtn.push_back(root);
            }
            else if(leftRes.size() == 0){
                for( auto rr : rightRes){
                    auto root = new TreeNode(i);
                    root->left = nullptr;
                    root->right = rr;
                    rtn.push_back(root);
                }
            } else if(rightRes.size() == 0){
                for( auto lr : leftRes){
                    auto root = new TreeNode(i);
                    root->left = lr;
                    root->right = nullptr;
                    rtn.push_back(root);
                }
            } else{
                for( auto lr : leftRes){
                    for( auto rr : rightRes){
                        auto root = new TreeNode(i);
                        root->left = lr;
                        root->right = rr;
                        rtn.push_back(root);
                    }
                }
            }
        }
        return rtn;
    }
};
```
```
执行用时：16 ms, 在所有 C++ 提交中击败了93.09%的用户
内存消耗：15.5 MB, 在所有 C++ 提交中击败了81.80%的用户
```