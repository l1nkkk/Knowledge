> 难度：中等
- 思路1：递归，有点难。但是可以很好的锻炼递归的写法
  - 参考：https://mp.weixin.qq.com/s/9RKzBcr3I592spAsuMH45g
  - **前序遍历可以理解为是从上往下，而后序遍历是从下往上**

遇到任何递归型的问题，无非就是灵魂三问：
1. 这个函数是干嘛的？
2. 这个函数参数中的变量是什么的是什么？
3. 得到函数的递归结果，你应该干什么？


- 思路2：
  - 先找p，找到则记录其路线
  - 再找q，找到则记录其路线
  - 然后从路线中找到祖先不一样的临界点


> 题目
<div align="center" style="zoom:60%"><img src="./pic/236-1.png"></div>


> 代码
## 思路1
```cpp
class Solution {
public:
    // 定义:
    // 如果p和q在root为根的树中，返回lca
    // 如果只有一个在，返回root
    // 都不在，返回nullptr
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;
        if(root == p || root == q) return root;

        TreeNode* left, *right;
        left = lowestCommonAncestor(root->left, p, q);
        right = lowestCommonAncestor(root->right, p, q);

        /** 后序遍历，自带自底向上特性，所以root一定是lca*/
        // 情况1
        if(left != nullptr && right != nullptr)
            return root;

        // 情况2
        if(left == nullptr && right == nullptr)
            return nullptr;
        // 情况3
        return left == nullptr? right:left;
    }
};
```

```
执行用时：12 ms, 在所有 C++ 提交中击败了97.43%的用户
内存消耗：13.9 MB, 在所有 C++ 提交中击败了76.78%的用户
```

## 思路2
```cpp

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> rcp;
        vector<TreeNode*> rcq;
        find(root, p, rcp);
        find(root, q, rcq);

        // 找最近的
        int posp = rcp.size()-1;
        int posq = rcq.size()-1;
        while(posp >= 0 && posq >= 0){
            if(rcp[posp] == rcq[posq]){
                --posp;
                --posq;
            } else{
                break;
            }
        }
        return rcp[posp+1];
    }

    bool find(TreeNode* root, TreeNode* target, vector<TreeNode*> &record){
        if(root == nullptr) return false;
        bool res = false;

        if(root->val == target->val) {
            record.push_back(root);
            return true;
        }
        res = find(root->left, target, record) || res;
        res = find(root->right, target, record) || res;
        if(res){
            record.push_back(root);
        }
        return res;
    }
};
```

```
执行用时：20 ms, 在所有 C++ 提交中击败了60.07%的用户
内存消耗：17.1 MB, 在所有 C++ 提交中击败了6.08%的用户
```