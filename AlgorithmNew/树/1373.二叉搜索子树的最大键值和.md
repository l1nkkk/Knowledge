> 难度：中等
- 思路：还是一样二叉树的框架（前序、后序、层序）
  - 在这里用后序会还一些。**如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历。**
  - 分为三步
    - 左右子树是不是BST
    - 取左边最大，右边最小，判断当前是不是BST
    - 计算累加和，是不是最大的

> 题目
<div align="center" style="zoom:80%"><img src="./pic/1173-1.png"></div>



> 代码


```cpp
class Solution {
public:
    int maxSumBST(TreeNode *root) {
        deal(root);
        return res;
    }
    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max){
        if(root == nullptr) return true;
        if(min != nullptr && root->val < min->val) return false;
        if(max != nullptr && root->val > max->val) return false;

        return checkBST(root->left, min, root) && checkBST(root->right, root, max);

    }
    static constexpr int FALSE=111111;

    int res = 0;
    // 判断是不是BST ，FALSE表明不是
    int deal(TreeNode* root){
        if(root == nullptr) return 0;
        // 判断左右是不是BST
        auto lres = deal(root->left);
        auto rres = deal(root->right);
        if(lres == FALSE || rres == FALSE) return FALSE;

        // 判断自己是不是BST
        int lmax, rmin;
        if(root->left != nullptr){
            lmax = getMax(root->left);
            if(lmax >= root->val) return FALSE;
        }
        if(root->right != nullptr){
            rmin = getMin(root->right);
            if(rmin <= root->val) return FALSE;
        }

        res = res < root->val + lres + rres ? root->val + lres + rres :res;
        return root->val + lres + rres;
    }
    int getMax(TreeNode *root){
        auto tm = root;
        int rtn;
        while(tm!= nullptr){
            rtn = tm->val;
            tm = tm->right;
        }
        return rtn;
    }

    int getMin(TreeNode *root){
        auto tm = root;
        int rtn;
        while(tm!= nullptr){
            rtn = tm->val;
            tm = tm->left;
        }
        return rtn;
    }

};
```

```
执行用时：128 ms, 在所有 C++ 提交中击败了99.52%的用户
内存消耗：91.2 MB, 在所有 C++ 提交中击败了88.52%的用户
```