> 难度：简单
- 思路：递归
  - https://mp.weixin.qq.com/s/OlpaDhPDTJlQ5MJ8tsARlA
- 把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了
```cpp
TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) {
    // 找到数组中的最大值
    TreeNode root = new TreeNode(6);
    // 递归调用构造左右子树
    root.left = constructMaximumBinaryTree([3,2,1]);
    root.right = constructMaximumBinaryTree([0,5]);
    return root;
}
```

> 题目
```
给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。

输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
```
<div align="center" style="zoom:60%"><img src="./pic/654-1.jpg"></div>

> 代码

```cpp
class Solution {
public:

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums, 0, nums.size());
    }
    // 递归定义：传入数组和[lo，hi)，生成符合题目要求的树，返回root
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo >= hi) return nullptr;
        // 找到最大
        int maxI = lo;
        for(int i = lo; i <hi; ++i){
            maxI = nums[maxI] < nums[i] ? i : maxI;
        }
        TreeNode* rtn = new TreeNode(nums[maxI]);
        rtn->left = build(nums, lo, maxI);
        rtn->right = build(nums, maxI+1, hi);
        return rtn;
    }
};
```