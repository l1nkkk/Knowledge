> 难度：中等
- 思路1：（一开始自己的思路）
  - 对每个节点代表的树序列化==》序列化后，对记录进行比对===》（再对左右子树相同处理）
  - 上面有一个缺点，许多节点要被遍历多遍（存在重复子结构），导致最后超时
  - 自顶向下
- 思路2：后序遍历才是正解
  - 参考：https://mp.weixin.qq.com/s/LJbpo49qppIeRs-FbgjsSQ
  - 两个关键：知道别人是什么，知道自己是什么（体现了需要序列化，另一个问题就是如何避免重复【通过后序遍历，让对root的操作延后，如果是前序遍历的话，这个时候还不知道自己的左右子树他们的情况是什么样的】）
  - 自底向上


> 代码

## 思路1：（超时了）
```cpp
class Solution {
public:
    // 定义：
    vector<TreeNode*> res;
    map<string, TreeNode*> mst;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        if(root == nullptr) return res;
        /** 前序遍历位置*/
        auto serStr = serialize(root);
        if(mst.find(serStr) == mst.end()) {
            mst[serStr] = root;
        }else{
            if(mst[serStr] != nullptr) {
                res.push_back(mst[serStr]);
                mst[serStr] = nullptr;
            }
        }
        findDuplicateSubtrees(root->left);
        findDuplicateSubtrees(root->right);

        return res;
    }
    string serialize(TreeNode* root){
        if(root == nullptr) return "#";
        string rtn;

        rtn += to_string(root->val) + ",";
        rtn += serialize(root->left) + ",";
        rtn += serialize(root->right);

        return rtn;
    }
};
```

## 思路2

```cpp
class Solution {
public:
    // 定义：
    vector<TreeNode*> res;
    map<string, TreeNode*> mst;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {

        if(root == nullptr) return res;
        traverse(root);
        return res;
    }
    string traverse(TreeNode* root){
        if(root == nullptr) return "#";
        string rtn;
        rtn += traverse(root->left) + ",";
        rtn += traverse(root->right)+ ",";
        rtn += to_string(root->val);
        /** 后序遍历位置*/
        if(mst.find(rtn) == mst.end()) {
            mst[rtn] = root;
        }else{
            if(mst[rtn] != nullptr) {
                res.push_back(mst[rtn]);
                mst[rtn] = nullptr;
            }
        }

        return rtn;
    }
};
```

```
执行用时：52 ms, 在所有 C++ 提交中击败了51.08%的用户
内存消耗：62.3 MB, 在所有 C++ 提交中击败了40.62%的用户
```