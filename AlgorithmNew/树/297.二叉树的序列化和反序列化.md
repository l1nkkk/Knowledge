# 难度：中等
- 思路：主要应用二叉树的框架
  - 法1：前序遍历
  - 法2：后序遍历
  - 法3：层序遍历


# 代码
## 前序遍历
```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        /** 前序遍历位置*/
        if(root == nullptr) return "#";
        string rtn;
        rtn = to_string(root->val) + ',';


        rtn += serialize(root->left) + ',';
        rtn += serialize(root->right);
        return rtn;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        return _deserialize(data);
    }
    TreeNode* _deserialize(string& data) {
        if(data == "") return nullptr;

        /** 前序遍历位置*/
        auto back =0;
        while(back != data.size() && data[back] != ',') ++back;
        string numstr = data.substr(0, back);
        if(back != data.size())
            data = data.substr(back+1,data.size());
        if(numstr == "#") return nullptr;
        auto rtn = new TreeNode(stoi(numstr));


        rtn->left = _deserialize(data);
        rtn->right = _deserialize(data);
        return rtn;
    }
    
};

```

```
执行用时：196 ms, 在所有 C++ 提交中击败了10.15%的用户
内存消耗：526.7 MB, 在所有 C++ 提交中击败了5.74%的用户
```

## 后序遍历

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    // 定义：输入 树根， 返回序列化后的字符串
    string serialize(TreeNode* root) {
        // base case
        if(root == nullptr) return "#";
        string rtn = "";
        rtn += serialize(root->left)+',';
        rtn += serialize(root->right)+',';

        /** 后序遍历位置*/
        rtn += to_string(root->val) ;
        return rtn;
    }

    // Decodes your encoded data to tree.
    // 思路，先找到根，再分别处理左右子树，但是需要先处理右子树
    TreeNode* deserialize(string data) {
        // 处理string
        vector<string> dv;
        while(data.find(',') != string::npos){
            dv.push_back(data.substr(0,data.find(',')));
            data = data.substr(data.find(',')+1);
        }
        dv.push_back(data);

        return _deserialize(dv);
    }

    // string 处理起来困难
    TreeNode* _deserialize(vector<string> &data) {
        if(data.size() == 0) return nullptr;

        auto bk = data.back();
        data.pop_back();
        if(bk == "#") return nullptr;

        // 根
        TreeNode *root = new TreeNode(stoi(bk));


        root->right = _deserialize(data);
        root->left = _deserialize(data);
        return root;
    }
};
```

```
执行用时：188 ms, 在所有 C++ 提交中击败了10.33%的用户
内存消耗：524.7 MB, 在所有 C++ 提交中击败了5.96%的用户
```

## 层序遍历解法

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string resStr;
    string serialize(TreeNode* root) {
        if(root == nullptr)
            return "";
        queue<TreeNode*> qtree;
        qtree.push(root);
        resStr += to_string(root->val)+ ',';

        while(!qtree.empty()){
            auto tempn = qtree.front();
            qtree.pop();
            if(tempn->left != nullptr){
                qtree.push(tempn->left);
                resStr += to_string(tempn->left->val) + ',';
            } else{
                resStr += "#,";
            }

            if(tempn->right != nullptr) {
                qtree.push(tempn->right);
                resStr += to_string(tempn->right->val)+ ',';
            }else {
                resStr += "#,";
            }
        }
        return resStr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data == "") return nullptr;
        vector<string> vs;
        // 处理data
        while(data.find(',') != string::npos){
            vs.push_back(data.substr(0,data.find(',')));
            if(data.find(',') == data.size()-1)
                break;
            data = data.substr(data.find(',')+1,data.size());
        }

        int pos = 0;
        queue<TreeNode*> qt;
        TreeNode* rtn = new TreeNode(stoi(vs[pos++]));
        qt.push(rtn);
        while(!qt.empty()){
            auto tempn = qt.front();
            qt.pop();

            // left
            if(vs[pos] == "#"){
                tempn->left = nullptr;
                ++pos;
            }else{
                tempn->left = new TreeNode(stoi(vs[pos++]));
                qt.push(tempn->left);
            }
            // right
            if(vs[pos] == "#"){
                tempn->right = nullptr;
                ++pos;
            }else{
                tempn->right = new TreeNode(stoi(vs[pos++]));
                qt.push(tempn->right);
            }
        }
        return rtn;
    }
};

```

```
执行用时：152 ms, 在所有 C++ 提交中击败了11.67%的用户
内存消耗：509.5 MB, 在所有 C++ 提交中击败了7.56%的用户
```