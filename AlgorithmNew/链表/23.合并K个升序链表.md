> 难度：简单
- 就是有点像外排序归并的思路
- 首先用一个优先队列，存入每个链表的最小以及其对应的哪个链表（pair）
- 每次从优先队列取出一个，然后被取出的从其原来的链表再补一个。如果没有了就不补了
- 直到优先队列为空

> 题目

```
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
```

> 代码

```cpp

struct cmp
{
    bool operator()(pair<ListNode *,int> a, pair<ListNode *,int> b)
    {
        if(a.first->val > b.first->val) return true;
        return false;
    }
};



class Solution {
public:
    // 后面觉得并不需要 索引字段
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 优先队列 pair<ListNode *, int> [表头, 索引]
        priority_queue<pair<ListNode *, int>, std::vector<pair<ListNode *,int>>, cmp> pq;
        ListNode *res = nullptr;
        ListNode *it = nullptr;
        
        // 1.init，初始化优先队列
        for(int i = 0; i < lists.size(); ++i){
            if(lists[i] == nullptr) continue;
            pq.push(make_pair(lists[i],i));
            lists[i] = lists[i]->next;
        }

        while(!pq.empty()){
            auto t = pq.top();
            pq.pop();

            // 2.更新：取出最小的一个链表，之后对该链表进行迭代
            if(lists[t.second]){
                pq.push(make_pair(lists[t.second],t.second));
                lists[t.second] = lists[t.second]->next;
            }

            // 3.加入结果：将取出的结果加入到res
            if(res == nullptr){
                res = t.first;
                it = t.first;
            }else{
                it->next = t.first;
                it = it->next;
            }
        }
        return res;
    }
};
```