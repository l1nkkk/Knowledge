> 难度：简单
- 用一个dequeue，先按序装入，后面分别从一头一尾取。
- 有更巧妙的，有空看
> 题目

<div align="center" style="zoom:60%"><img src="./pic/142.1.png"></div>

> 代码

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head == nullptr) return;
        deque<ListNode*> nodeq;
        ListNode *itn = head;
        while(itn != nullptr){
            nodeq.push_back(itn);
            itn = itn->next;
        }
        ListNode *lo;
        ListNode *hi;

        while(!nodeq.empty()){
            hi = nodeq.back();
            nodeq.pop_back();
            if(nodeq.empty()) break;

            lo = nodeq.front();
            nodeq.pop_front();

            hi->next = lo->next;
            lo->next = hi;
        }

        hi->next = nullptr;
    }
};
```
```
执行用时：36 ms, 在所有 C++ 提交中击败了81.41%的用户
内存消耗：18.1 MB, 在所有 C++ 提交中击败了29.87%的用户
```