> 嵌入的是非指针
```go
type Duck struct {
	name  string
	color string
}

func (d *Duck) PrintColor() {
	fmt.Println(d.color)
}

func (d *Duck) Speak() {
	fmt.Println("gagaga")
}

func (d *Duck) MakeFriend(pd *Duck) {
	fmt.Println(d.name + "make friend with" + pd.name)
}

type ToyDuck struct {
	Duck
	makeIn string
}

// 重点4：嵌入Duck，相当于定义了方法
// func (d *ToyDuck) Speak() {
// 	fmt.Println("gagaga")
// }
func (td *ToyDuck) PrintMade() {
	fmt.Println(td.makeIn)
}

func (td *ToyDuck) MakeFriend(ptd *ToyDuck) {
	// 重点3：可以访问得到，即使是小写的
	fmt.Println(td.name + " make friend with " + ptd.name)
}

func main() {
	// 重点2：初始化方式1
	var t1 ToyDuck = ToyDuck{
		Duck: Duck{
			color: "yello",
			name:  "linqing",
		},
		makeIn: "China",
	}

	// 重点2：初始化方式2
	var t2 ToyDuck = ToyDuck{Duck{"yello", "l1nkkk"}, "China"}

	// 重点1：；如果没有在ToyDuck中定义MakeFriend的话，将error，因为其是has a Duck,
	// 而不是 is a Duck
	t1.MakeFriend(&t2)

}
```

> 嵌入指针
- 共享Font
```go
type Font struct {
	color string
	size  int64
}

type Section struct {
	*Font
	text string
}

func main() {
	var font Font = Font{"red", 16}
	var s1 Section = Section{&font, "l1nkk"}
	var s2 Section = Section{&font, "qing"}
	fmt.Println(s1)
	fmt.Println(s2)
}

```

