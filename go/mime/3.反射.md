- 参考（非常详细）：https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/
  - 已经剪藏到印象笔记

- [概述](#概述)
- [最重要的两个类型：reflect.Type 和 reflect.Value](#最重要的两个类型reflecttype-和-reflectvalue)
- [三大原则](#三大原则)
- [reflect 类型和值的底层实现](#reflect-类型和值的底层实现)
  - [Type](#type)
  - [Value](#value)
- [更新变量细节](#更新变量细节)
- [在reflect中判断，Value是否实现某个接口](#在reflect中判断value是否实现某个接口)
- [在reflect中进行方法调用](#在reflect中进行方法调用)

# 概述
- `reflect` 实现了运行时的反射能力，能够让程序操作不同类型的对象（而不用把类型写死）
- 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以**减少重复代码**，但是过量的使用反射会使我们的**程序逻辑变得难以理解**并且运行缓慢。


# 最重要的两个类型：reflect.Type 和 reflect.Value
- `reflect` 两个最重要的函数和类型，这两个函数和类型**一一对应**
  - `reflect.TypeOf(interface{})` 能获取**类型信息**，即 `reflect.Type`；
  - `reflect.ValueOf(interface{})` 能获取**数据的运行时表示**，即 `reflect.Value`；
<div style="zoom:40%" align="center"><img src="./pic/3-1.png"></div>

- 通过 `reflect.TypeOf`、`reflect.ValueOf` 可以将一个普通的变量转换成反射包中提供的 `reflect.Type` 和 `reflect.Value`(称为 reflect 的类型与值)，随后就可以使用反射包中的方法对它们进行复杂的操作


> reflect.Type 
- 接口类型
  - 通过 `reflect.TypeOf` 函数将任意变量入参，得到 `reflect.Type`

- 一些方法：
  - `Method` 方法获得类型实现的方法
  - `Field` 获取类型包含的全部字段
  - 对于不同的类型，我们也可以调用不同的方法获取相关信息    
    - 结构体：获取字段的数量并通过下标和字段名获取字段 `StructField`
    - 哈希表：获取哈希表的 `Key` 类型
    - 函数或方法：获取入参和返回值的类型
```go
type Type interface {
    Align() int
    FieldAlign() int
    Method(int) Method
    MethodByName(string) (Method, bool)
    NumMethod() int
    ...
    Implements(u Type) bool
    ...
}
```

> reflect.Value
- 结构体
  - 没有对外暴露的字段，但是提供了获取或者写入数据的方法
  - 通过 `reflect.ValueOf` 函数将任意变量入参，得到 `reflect.Value`

```go
type Value struct {
        // 包含过滤的或者未导出的字段
}

func (v Value) Addr() Value
func (v Value) Bool() bool
func (v Value) Bytes() []byte
...
```

# 三大原则
1. 从 interface{} 变量可以反射出反射对象（即`reflect.Type` 和 `reflect.Value`）
   - 任何类型在转化为反射对象之前，都是先转化成 `interface{}`
2. 从反射对象可以获取 interface{} 变量（即上一条的反操作）
   - 从反射对象可以获取 `interface{}` 变量
3. 要修改反射对象，其值必须可被更新
   - 需要是一个指针类型，本质是因为golang里的函数全都是值传递。
<div style="zoom:40%" align="center"><img src="./pic/3-2.png"></div>



> demo:与reflect对象的互相转化
```go
func demo1(){
	author := "testdemo1"

	// 1. 转化成reflect类型
	fmt.Println("Typeof : ", reflect.TypeOf(author))
	fmt.Println("Valueof : ", reflect.ValueOf(author))

    // 2. 转化成原始对象 
	v := reflect.ValueOf(author)
	fmt.Println("original value:", v.Interface().(string))// 类型断言
}

```

```
Typeof :  string
Valueof :  testdemo1
original value: testdemo1
```

> demo：第三个原则的验证
- 更新值的错误姿势
```go
func demo2(){
	i := 1
	// 值传递
	v := reflect.ValueOf(i)
	v.SetInt(10)
	fmt.Println(i)
}
```
```
panic: reflect: reflect.Value.SetInt using unaddressable value
```

- 更新值的正确姿势
  - 调用 reflect.ValueOf 获取变量指针；
  - 调用 reflect.Value.Elem 获取指针指向的变量；
  - 调用 reflect.Value.SetInt 更新变量的值：
```go
func demo3(){
	i := 1
	// 值传递，传入的是指针；获取指针对应的 reflect.Value类型
	v := reflect.ValueOf(&i)
	// reflect.Value.Elem: 获取指针指向的变量（reflect.Value类型）
	// reflect.Value.SetInt 更新变量的值
	v.Elem().SetInt(10)
	fmt.Println(i)
}
```

- 上述程序相当于: 
```go
i := 1
v := &i
*v = 10
```

# reflect 类型和值的底层实现


- Go 语言的 interface{} 类型在语言内部是通过 reflect.emptyInterface 结体表示的
  - `rtype` 字段用于表示变量的类型
  - `word` 字段指向内部封装的数据
```go
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}
```

## Type
- `TypeOf 原理`：将一个 `interface{}` 变量转换成了内部的 `reflect.emptyInterface` 表示，然后从中获取相应的类型信息
  - `rtype` 里面有许多成员变量，其实现了 `Type` 接口
```go
// reflect 内部的TypeOf实现
func TypeOf(i interface{}) Type {
    // unsafe.Pointer 是一个类型（int类型的type重定义），
    // 这里是进行类型转换成 unsafe.Pointer，
    // 再将类型转换成*emptyInterface，最后进行解引用赋值
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}

func toType(t *rtype) Type {
	if t == nil {
		return nil
	}
	return t
}
```

## Value

```go

// reflect 内部的 ValueOf 实现
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}
    // 调用 reflect.escapes 保证当前值逃逸到堆上
	escapes(i)

    // 通过 reflect.unpackEface 从接口中获取 reflect.Value 结构体
	return unpackEface(i)
}

func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&i))
	t := e.typ
	if t == nil {
		return Value{}
	}
	f := flag(t.Kind())
	if ifaceIndir(t) {
		f |= flagIndir
	}
	return Value{t, e.word, f}
}
```

# 更新变量细节
- 太复杂，需要再去了解

# 在reflect中判断，Value是否实现某个接口

- 获取结构体的反射类型：`reflect.TypeOf`
- 获取接口的反射类型：`reflect.TypeOf((*<interface>)(nil)).Elem()`
- 通过 `reflect.Type` 的 `Implements` 方法可以用于判断某些类型是否遵循特定的接口

> demo
```go
type CustomError struct{}

func (*CustomError) Error() string {
	return ""
}

func main() {
	typeOfError := reflect.TypeOf((*error)(nil)).Elem()
	customErrorPtr := reflect.TypeOf(&CustomError{})
	customError := reflect.TypeOf(CustomError{})

	fmt.Println(customErrorPtr.Implements(typeOfError)) // #=> true
	fmt.Println(customError.Implements(typeOfError)) // #=> false
}
```

> Implement 实现细节
```go
func (t *rtype) Implements(u Type) bool {
    // 检查传入的类型是不是nil
	if u == nil {
		panic("reflect: nil type passed to Type.Implements")
	}
    // 检查传入的类型是不是接口
	if u.Kind() != Interface {
		panic("reflect: non-interface type passed to Type.Implements")
	}
	return implements(u.(*rtype), t)
}
```

- implements: 对比 `T` 中方法，在 `V` 中是否都被实现了。
  - 由于**方法都是按照字母序存储的**，reflect.implements 会维护两个用于遍历接口和类型方法的索引 i 和 j 判断类型是否实现了接口，因为最多只会进行 n 次比较（类型的方法数量），所以整个过程的时间复杂度是 O(n)。


<div style="zoom:40%" align="center"><img src="./pic/3-3.png"></div>

```go
func implements(T, V *rtype) bool {
	t := (*interfaceType)(unsafe.Pointer(T))
	if len(t.methods) == 0 {
		return true
	}
	...
	v := V.uncommon()
	i := 0
	vmethods := v.methods()
	for j := 0; j < int(v.mcount); j++ {
		tm := &t.methods[i]
		tmName := t.nameOff(tm.name)
		vm := vmethods[j]
		vmName := V.nameOff(vm.name)
		if vmName.name() == tmName.name() && V.typeOff(vm.mtyp) == t.typeOff(tm.typ) {
			if i++; i >= len(t.methods) {
				return true
			}
		}
	}
	return false

```

# 在reflect中进行方法调用
> demo: 使用反射来执行 Add(0,1) 函数
- 使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。

```go
func Add(a, b int) int { return a + b }

func main() {
    // 1. 通过 reflect.ValueOf 获取函数 Add 对应的反射 Value对象；
    // 并通过 Value.Type() 方法获得 反射 Type 对象
	v := reflect.ValueOf(Add)
	if v.Kind() != reflect.Func {
		return
	}
	t := v.Type()

    // 2. 调用 reflect.rtype.NumIn 获取函数的入参个数；
	argv := make([]reflect.Value, t.NumIn())

    // 3. 多次调用 reflect.ValueOf 函数逐一设置 argv 数组中的各个参数
	for i := range argv {
		if t.In(i).Kind() != reflect.Int {
			return
		}
		argv[i] = reflect.ValueOf(i)
	}

    // 4. 调用反射对象 Add 的 reflect.Value.Call 方法并传入参数列表
	result := v.Call(argv)

    // 5. 获取返回值数组、验证数组的长度以及类型并打印其中的数据；
	if len(result) != 1 || result[0].Kind() != reflect.Int {
		return
	}
	fmt.Println(result[0].Int()) // #=> 1
}
```

- 源码细节不管，太复杂