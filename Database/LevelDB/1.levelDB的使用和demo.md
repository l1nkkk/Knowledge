- [基本使用](#基本使用)
  - [CURD](#curd)
  - [原子更新](#原子更新)
  - [同步写和异步写](#同步写和异步写)
  - [并发安全](#并发安全)
  - [迭代器](#迭代器)
  - [快照](#快照)
- [细节](#细节)
  - [Slice](#slice)
  - [Comparators](#comparators)
    - [向后兼容](#向后兼容)
  - [Block](#block)
  - [Compression](#compression)
  - [cache](#cache)
  - [键的布局技巧](#键的布局技巧)
  - [校验和](#校验和)
  - [获取键范围的size](#获取键范围的size)
  - [Env](#env)
- [阅读源码重点看的几个点](#阅读源码重点看的几个点)

# 基本使用
## CURD
- `/tmp/testdb`：持久化所在目录
- `delete db`：关闭数据库
- `leveldb::Status`：大部分函数都返回此类型数据，表示执行状态
```cpp
void demo1(){

    // Init
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
    assert(status.ok());

    // Put
    {
        leveldb::Slice key1("test1");
        status = db->Put(leveldb::WriteOptions(), key1, "data1");
        assert(status.ok());

        leveldb::Slice key2("test2");
        status = db->Put(leveldb::WriteOptions(), key2, "data2");
        assert(status.ok());
    }

    // Get
    {
        leveldb::Slice key1("test1");
        std::string val1;
        status = db->Get(leveldb::ReadOptions(), key1, &val1);
        assert(status.ok());
        cout << "Get ket:" << key1.ToString() << ", val:"<< val1 << endl;
    }

    // Update
    {
        leveldb::Slice key1("test1");
        std::string val1;
        status = db->Put(leveldb::WriteOptions(), key1, "data3");
        assert(status.ok());

        status = db->Get(leveldb::ReadOptions(), key1, &val1);
        assert(status.ok());
        cout << "Get ket:" << key1.ToString() << ", val:"<< val1 << endl;
    }

    // Delete
    {
        leveldb::Slice key1("test1");
        std::string val1;
        status = db->Delete(leveldb::WriteOptions(), key1);
        assert(status.ok());

        status = db->Get(leveldb::ReadOptions(), key1, &val1);
        if(status.IsNotFound())
            cout << "Not Found" << endl;
    }
    // Closing db
    delete db;
}
```

## 原子更新
- 重点：可中断
  - 比如：Put----Del。再Put之后挂了，Put做的修改不会被持久化
- 应用：
  - 比如一个业务操作需要同时该许多数据的时候
- 头文件：`leveldb/write_batch.h`
- 细节：按序，下面的demo先 `Delete` 再 `Put`
```cpp
void demo2(){
    // Init
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
    assert(status.ok());

    // Put
    leveldb::Slice k1 = "key1";
    leveldb::Slice k2 = "key1";
    status = db->Put(leveldb::WriteOptions(), k1, "1");
    assert(status.ok());

    // Use Atomic Update
    string val;
    status = db->Get(leveldb::ReadOptions(), k1, &val);
    if(status.ok()){
        // 重点
        leveldb::WriteBatch batch;
        batch.Delete(k1); // 先删除再Put，避免k1 == k2 的情况
        batch.Put(k2, "2");
        status = db->Write(leveldb::WriteOptions(), &batch);    // commit
        assert(status.ok());
    }


    status = db->Get(leveldb::ReadOptions(), k1, &val);
    assert(status.ok());
    cout << "after update:" << val << endl;

};
```

## 同步写和异步写
- 同步写：等到持久化到磁盘就返回
- 异步写：写到内存中就返回
  - 默认
- 考量：可靠性与效率
  - 异步写入通常比同步写入快一千倍（官方文档写的）
- 混合方案：
  - eg：在第n个写操作的时候sync写入。崩溃时取最新后一个同步写入之后的重新启动
- 一种平摊同步写入额外成本的方式：使用 `WriteBatch`，多个写一起同步写入。

> 测试：10000次put比较同步和异步写
```cpp
void demo3(){
    // Init
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
    assert(status.ok());
// do something...

    // 重点：sync，同步
    auto start = system_clock::now();
    leveldb::WriteOptions opt_sync;
    opt_sync.sync = true;
    for(int i = 0; i < 10000; ++i){
        leveldb::Slice key = to_string(i);
        db->Put(opt_sync, key, key);
    }
    auto end   = system_clock::now();
    auto duration = duration_cast<microseconds>(end - start);
    cout <<  "sync use "
         << double(duration.count()) * microseconds::period::num / microseconds::period::den
         << " s" << endl;

    // 重点：async，异步
    start = system_clock::now();
    leveldb::WriteOptions opt_async;
    opt_async.sync = false;
    for(int i = 0; i < 10000; ++i){
        leveldb::Slice key = to_string(i);
        db->Put(opt_async, key, key);
    }
    end = system_clock::now();
    duration = duration_cast<microseconds>(end - start);
    cout <<  "async use "
         << double(duration.count()) * microseconds::period::num / microseconds::period::den
         << " s" << endl;

    delete db;
}
```

```cpp
sync use 6.48449 s
async use 0.026768 s
```

## 并发安全
- 线程安全的操作：Get、写入、获取迭代器
- 需要外部应用同步的操作对象（非线程安全）：`Iterator`和`WriteBatch`
  - eg：多个线程用同一个迭代器
  - eg：多个线程往Batch里add操作


## 迭代器

```cpp
void demo4(){
    // Init
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
    assert(status.ok());
    
    // 迭代器使用，后向迭代
    leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions());
    for(it->Seek("100"); it->Valid() && it->key().ToString() < "200"; it->Next()){
        cout << it->key().ToString() << endl;
    }
}
```

```
100
1000
10000
10001
10002
10003
10004
10005
10006
...
```

## 快照
- 我的理解：避免了读倾斜（可重复读隔离级别）
- 快照为键值存储的整个状态提供一致的**只读视图**
- `ReadOptions::snapshot`：
  - 不为null的时候，指示读取应该对特定版本的DB状态进行。
  - 为null的时候，读取将对当前状态的**隐式快照**进行。
```cpp
void demo5() {
    // Init
    leveldb::DB *db;
    leveldb::Options options;
    options.create_if_missing = true;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
    assert(status.ok());

    // 提供一个只读的视图
    leveldb::ReadOptions opt;
    opt.snapshot = db->GetSnapshot();   // 重点：获取视图
    leveldb::Slice key("1");
    string val;
    status = db->Get(opt, key, &val);
    assert(status.ok());
    cout << "before update " << val << endl;

    // ...尝试做些修改
    db->Put(leveldb::WriteOptions(), key, val+"_");

    // 再次GET
    status = db->Get(opt, key, &val);
    assert(status.ok());
    cout << "after update " << val << endl;

    delete db;
}
```

```
before update 1_
after update 1_
```

# 细节
## Slice
- `Slice`：有点类似go的slice。
  - 数据结构：一个长度 和 一个指向外部字节数组的指针
  - 可以和`std::string`很好的转换
- **目的**：返回 `Slice` 比返回 `std::string` 更加廉价，因为**不用大量的键值的拷贝**

> 使用时注意避免该bug
```cpp
leveldb::Slice slice;
if (...) {
    std::string str = ...;
    slice = str;    // 是lice指向str所指向的字符串
}
// bug：str被析构，slice背后指向的数据也被销毁
Use(slice);
```

## Comparators
- LevelDB默认会按Key的字节序存储，也可以自定义。
- 使用自定义的cmp的时候，考虑向后兼容
  - 就是如果后面换了cmp方案，怎么办？

> 使用方式
- 定义接口
```cpp
class TwoPartComparator : public leveldb::Comparator {
public:
// Three-way comparison function:
//   if a < b: negative result
//   if a > b: positive result
//   else: zero result
int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const {
    int a1, a2, b1, b2;
    ParseKey(a, &a1, &a2);
    ParseKey(b, &b1, &b2);
    if (a1 < b1) return -1;
    if (a1 > b1) return +1;
    if (a2 < b2) return -1;
    if (a2 > b2) return +1;
    return 0;
}

// Ignore the following methods for now:
const char* Name() const { return "TwoPartComparator"; }
void FindShortestSeparator(std::string*, const leveldb::Slice&) const { }
void FindShortSuccessor(std::string*) const { }
};
```
- 使用
```cpp
    int main(){
    TwoPartComparator cmp;
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    options.comparator = &cmp;
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &db);
}
```

### 向后兼容
- cmp中的`Name` 方法的返回会附加在LevelDB中，LevelDB 在打开数据库的时候，会**检查cmp的名字，如果更改，open出错**。
  - 要直接该名称可以，但是需要所有库删完
- 向后兼容方案
  - 名字还是不变
  - 在key的设计上跟上 **一个字节的版本号**
  - 再`Compare`中去区分哪个版本的，以及怎么处理

## Block
- 持久化存储基本单元
- 磁盘和缓存传输的基本单元
- 默认为4096个字节（未压缩的）
- 官方建议：不要小于1KB，也不要大于几MB。
- 大点好：批量扫描
- 小点好：大量少量读取
- 

## Compression
- 每个block在持久化前，会被压缩
> 不压缩方法
```cpp
leveldb::Options options;
options.compression = leveldb::kNoCompression;
... leveldb::DB::Open(options, name, ...) ....
```

## cache
- 用于缓存 经常使用的**未压缩的块**
  - 注意是未压缩的块，所以注意根据数据规模来设置空间
  - 打开`options.cache`，使其非null
```cpp
#include "leveldb/cache.h"

leveldb::Options options;
options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache
leveldb::DB* db;
leveldb::DB::Open(options, name, &db);
... use the db ...
delete db
delete options.cache;
```
> 禁用缓存
- **场景**：**大批量读取的时候**，可能会使原来的缓存失效，为了避免这种情况。
```cpp
leveldb::ReadOptions options;
options.fill_cache = false; // 避免使用缓存
leveldb::Iterator* it = db->NewIterator(options);
for (it->SeekToFirst(); it->Valid(); it->Next()) {
...
}
```
## 键的布局技巧
- key彼此靠近，在读取的时候会更快，可以以此提高性能。
  - 但是现在如果想把一些不常用的数据放置在其他地方，避免其被扫到缓存里面，可以通过如下的方式
    - 可以对于元数据，再前缀上加上`/`。这**样在读取扫描元数据的时候，不会把大量的业务数据也读取到缓存**
```sh
# 元数据
filename -> permission-bits, length, list of file_block_ids
# 业务数据
file_block_id -> data
```
## 校验和
- 与文件系统相关联
- 有以下两个独立的控制
  - `ReadOptions::verify_checksums`：读取时设置，对所读取到的所有数据进行验证
    - 默认不设置
  - `Options::paranoid_checks `：打开数据库时设置，
    - 默认不设置
    - 如果已经被打开了（自己或者其他进程），则raise error

## 获取键范围的size
- 作用：用于获取 **一个或多个** 键范围使用的文件系统空间的大致字节数
```cpp
leveldb::Range ranges[2];
ranges[0] = leveldb::Range("a", "c");
ranges[1] = leveldb::Range("x", "z");
uint64_t sizes[2];// size[0]:ranges[0]的近似size
leveldb::Status s = db->GetApproximateSizes(ranges, 2, sizes);
```

## Env
- 所有levelDB产生的错误都被路由到`leveldb::Env`中，可以自定义，以追求更好的操作
  -  For example, an application may introduce artificial delays in the file IO paths to limit the impact of leveldb on other activities in the system.
```cpp
class SlowEnv : public leveldb::Env {
.. implementation of the Env interface ...
};

SlowEnv env;
leveldb::Options options;
options.env = &env;
Status s = leveldb::DB::Open(options, ...);
```


# 阅读源码重点看的几个点
- 缓存设计
  - LRU是怎么用的
  - 写缓存：跳表
  - 读缓存：未知
- 线程安全
  - 如何保证多个线程Get Put ... 的安全
- 压缩
  - 如何做的压缩
- Batch的实现
- 版本控制
  - 只读快照是怎么实现的
- 查询
  - 查询流程
- 持久化
  - 如何从内存中持久化到磁盘，如何保证这个时候的写
- 体会
  - 为什么要用slice，而不用string
  - 块什么时候应该大，什么时候应该小
