https://github.com/jason--liu/Blog/issues/4

- [3.套接字编程简介](#3套接字编程简介)
  - [套接字地址结构](#套接字地址结构)
    - [sockaddr_in：IPv4](#sockaddr_inipv4)
    - [sockaddr_in6：IPv6](#sockaddr_in6ipv6)
    - [sockaddr：旧通用套接字地址结构](#sockaddr旧通用套接字地址结构)
    - [sockaddr_storage：新的通用套接字地址结构](#sockaddr_storage新的通用套接字地址结构)
    - [总结](#总结)
    - [思考](#思考)
  - [值-结果参数](#值-结果参数)
  - [大小端](#大小端)
    - [大小端字节序](#大小端字节序)
    - [测试大小端的代码](#测试大小端的代码)
    - [转换函数](#转换函数)
  - [关于字节操作的函数](#关于字节操作的函数)
  - [地址表示与数值的转换](#地址表示与数值的转换)
    - [协议无关的转换](#协议无关的转换)

# 3.套接字编程简介
## 套接字地址结构
### sockaddr_in：IPv4
- <netinet/in.h>
```cpp
// ipv4 套接字地址结构
// 使用单独的结构体存储 IP 地址有历史原因，早期in_addr是一个联合体，但是现在是无类地址编码，所以也就不需要该联合了。
struct in_addr{
	in_addr_t s_addr;  // 32 位的 IP 地址（uint32_t）
};

struct sockaddr_in{
	uint8_t        sin_len;      // 套接字地址的长度，并不是所有厂家都支持，而且POSIX规范不要求，在我自己的unbuntu上没看到有，所有的地址结构都不包括
	sa_family_t    sin_family;   // AF_INET（unsigned short）
	in_port_t      sin_port;     // 16 位的 ipv4 或 ipv6 端口号（uint16_t）
	struct in_addr sin_addr;     // 32 位 ipv4 地址
	char           sin_zero[8];
}；
```
- 无须设置和检查 sin_len 字段，除非涉及路由套接字
- POSIX只关注三个字段即可：**`sin_family, sin_addr, sin_port`**
  - `sin_addr`和`sin_port`总是以外露哦字节序来存储
  - sin_family再IPv4中为AF_INET
- `sin_zero`未曾使用，不过一般我们都初始化为0


### sockaddr_in6：IPv6
- <netinet/in.h>
- 关注三个字段即可：**`sin_family, sin_addr, sin_port`**
- IPv6 的地址族是 AF_INET6，IPv4 的地址族是 AF_INET.
- sin6_flowinfo 字段分为两个字段：
  - 低序 20 位是流标；
  - 高序 12 位保留；
```cpp
struct in6_addr{
	unit8_t s6_addr[16];  // 128bit IPV6 地址
};
#define SIN6_LEN
struct sockaddr_in6{
	uint8_t         sin6_len;       // 一般没有，不用管
	sa_family       sin6_family;
	in_port_t       sin6_port;
	uint32_t        sin6_flowinfo;
	struct in6_addr sin6_addr;
	uint32_t        sin6_scope_id;
};
```

### sockaddr：旧通用套接字地址结构
- <sys/socket.h>
- 目的：可以使套接字函数支持**任何协议族**的套接字地址结构
  - **IPv6也可以支持，比如在`connect bind getaddrinfo`中**，即使类型的字节数比他多。`(struct sockaddr_storage *)(void *)(addr)`，其中addr为`sockadd`r类型
- 从应用程序员看，这个结构的唯一作用就是用来强制类型转换的而已。
```cpp
struct sockaddr{
	uint8_t      sa_len;
	sa_family_t  sa_family;
	char         sa_data[14];
};
```



### sockaddr_storage：新的通用套接字地址结构
- <netinet/in.h>
- 针对IPv6相对sockaddr过长的限制
- 和旧的通用套接字地址相比差异
  - 如果系统支持任何套接字地址结构有对其需要，sockaddr_storage可以满足最苛刻的对其要求
  - sockaddr_storage足够大，可以满足系统支持的所有套接字地址结构
```cpp
struct sockaddr_storage{
	uint8_t     ss_len;     // length
	sa_family_t ss_family;  // AF_XXX
	// 其余的字段对用户来说是透明的，转换为特定地址结构进行使用
};
```

### 总结
<div style="zoom: 60%" align="center"> <img src="./pic/3-1.png"></div>

### 思考
- 关于IPv6的`sockaddr_in6*`与`sockaddr*`之间的类型转换是可以的，也就是说参数类型为`sockaddr*`的话，可以传入`sockaddr_in6*`，因为一般函数在传入之后还会再传入一个结构长度。

## 值-结果参数
- 在传递结构的长度的时候（如地址的结构），可能是传值，也可能是传引用，**传递方式取决于该结构的传递方向**
    - 进程到内核，如`bind(), connect(), sendto()`
    ```cpp
    struct sockaddr_in serv;  
    connect(sockfd, (SA*) &serv, sizeof(serv)); //其中大小参数的类型是socklen_t(uint32_t) 
    ```
  - 内核到进程(传引用，为了让内核修改后作为结果返回。)，如`accept(), recvfrom(), getsockname(), getpeername()`

## 大小端
### 大小端字节序
- 网络字节序是大端的
<div style="zoom: 60%" align="center"> <img src="./pic/3-2.png"></div>

### 测试大小端的代码
```cpp
int main(int argc, char** argv){
	union{
		short s;
		char c[sizeof(short)];
	} un;
	un.s = 0x0102;
	if (sizeof(short) == 2){
		if(un.c[0] == 1 && un.c[1] == 2){
            // 高位在低字节
			printf("big endian\n");
		}
		else if(un.c[0] == 2 && un.c[1] == 1){
			printf("little endian\n");
		}
		else{
            // 高位在高字节
			printf("unknow");
		}
	}
	exit(0);
}
```

### 转换函数
```cpp
#include<netinet/in.h>
uint16_t htons(uint16_t );
uint32_t hton1(uint32_t );   //均返回，网络字节序的值
uint16_t ntohs(uint16_t );
uint32_t ntoh1(uint32_t );   //均返回，主机字节序的值
```
- h -> host, n -> network, s -> short(16), l -> long(32)
- 在系统是大端的操作系统中，这四个函数一般为空

## 关于字节操作的函数
- 作者推荐使用`bzero`，不容易出错
```cpp
#include<strings.h> 
void bzero(void* dest, size_t nytes) .
void bcopy(const void* src, void* dest, size_t nbytes)
int bcmp(const void* ptrl, const void* ptr2, size_t nbytes)

void *memset(void* desk, int e, size_t len); 
void *memcpy(void* desk, const void* src, size_t nbytes); 
int memcpy(const void* ptrl, const void* ptr2, size_t nbytes); 
```

## 地址表示与数值的转换
- a:"address"; n:"numberic"
```cpp
#include<arpa/inet.h>
int inet_aton(const char* strptr, struct in_addr* addr_ptr);   //若字符串有效则为1，否则为0
in_addr_t inet_addr(const char* strptr);     //若字符串有效，则返回32位二进制IPv4地址，否则为INADDR_NONE（通常为32位均为1的值）有bug，已经废弃
char* inet_ntoa(struct in_addr inaddr);      //返回一个指向点分十进制的字符串指针
```

> 推荐使用
- 这两个函数拓展了对IPv6的支持，现在基本都使用这两个
- p:"persentation"; n:"numeric"

```cpp
#include<arpa/inet.h>
// family 代表转换地址的类型
int inet_pton(int family, const char* strptr, void* addrptr);   //成功返回1，失败返回0，出错返回-1
const char* inet_ntop(int family, const void* addrptr, char* strptr, size_t len);     //成功返回指向字符串的指针，失败返回NULL
```
### 协议无关的转换
- 使用 `inet_pton` 和 `inet_ntop`的时候需要传入family，造成代码与协议相关不好移植。
```cpp
char* sock_ntop(const struct sockaddr* sa, socklen_t salen){
	char portstr[8];
	static char str[128];
	switch(sa->sa_family){
		case AF_INET: {
			struct sockaddr_in* sin = (struct sokaddr_in *) sa;

			if(inet_ntop(AF_INET, &sin->sin_addr, str, sizeof(str)) == NULL)
				return (NULL);
			if(ntohs(sin->sin_port) != 0){
				snprintf(portstr, sizeof(portstr), ":%d", ntohs(sin->sin_port));
				strcat(str, portstr);
			}
			return(str);
		}
        case AF_INET6:{
            ...
        }
	}
}
```