- 参考
  - https://freestyler.pixnet.net/blog/post/23872864
  - https://lday.me/2017/11/04/0016_what_is_memory_barriers/
  - https://zhuanlan.zhihu.com/p/43526907
  - 《程序员的自我修养》
- [内存屏障](#内存屏障)
- [内存乱序](#内存乱序)
  - [什么是内存乱序访问](#什么是内存乱序访问)
  - [体会内存乱序带来的问题](#体会内存乱序带来的问题)
  - [编译时内存乱序访问](#编译时内存乱序访问)
  - [运行时的内存乱序](#运行时的内存乱序)
- [线程常见问题](#线程常见问题)
  - [demo1](#demo1)
    - [分析](#分析)
    - [解决：加锁](#解决加锁)
    - [解决：锁+volatile](#解决锁volatile)
    - [解决：锁+内存屏障](#解决锁内存屏障)

- 注：这玩意贼复杂，编译器的还好理解，运行时的涉及许多cache相关体系结构的东西，后面再看了。
  - 目前大概看懂这个就行了：https://lday.me/2017/11/04/0016_what_is_memory_barriers/
# 内存屏障
- **什么是内存屏障**
  - 内存屏障是一种底层原语，在不同计算机架构（Inter，ARM）下有不同的实现细节

- 为什么要有内存屏障
  - **内存乱序访问**。程序实际运行时很可能并不完全按照开发者编写的顺序访问内存
  - 缓存带来的麻烦

# 内存乱序
## 什么是内存乱序访问
```cpp
x = r;
y = 1；
```
- 实际运行可能是先执行`y = 1`，再执行`x = r`，这就是内存乱序访问
- 内存乱序访问
  - **编译时**。**编译器**的优化导致指令重排
  - **运行时**。多CPU（注，不是多线程，而是SMP架构，单核下不会发生）
    - **CPU**为了追求更快效率而乱序执行

## 体会内存乱序带来的问题
```cpp
// thread 1
while(!ok);
do(x);

// thread 2
x = 42;
ok = 1;
```
- 如果thread2乱序，另 `ok` 先初始化，这个时候 `x` 还没被赋值，会带来意想不到的结果。 

## 编译时内存乱序访问
> 例子
```cpp
int x, y, r;
void f()
{
    x = r;
    y = 1;
}
```
- `g++ -S test.cpp`，编译得到汇编代码如下:
  - 这个时候 `x = r`和`y = 1`并没有乱序执行
```asm
movl    r(%rip), %eax
movl    %eax, x(%rip)
movl    $1, y(%rip)
```

- `g++ -O2 –S test.cpp`，编译得到汇编代码如下
  - 可以看到优化了之后乱序了
```asm
movl    r(%rip), %eax
movl    $1, y(%rip)
movl    %eax, x(%rip)
```

> 解决
- 法1：使用 `volatile` 关键字：只能解决**编译器**编译时的优化
- 法2：使用 `barrier()`(linux 提供的)：解决编译和运行时的内存乱序访问。内核实现barrier()如下：
```cpp
#define barrier() __asm__ __volatile__("": : :"memory")

```
- 解决1
  - `volatile int x, y, r;`
- 解决2
```cpp
int x, y, r;
void f()
{
    x = r;
    // barrier() 等价的
    __asm__ __volatile__("": : :"memory")
    y = 1;
}
```
- 解决3：`ACCESS_ONCE`
  - 通过 `volatile` 实现的  
    - `#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))`
  - Linux内核中，宏 `ACCESS_ONCE` 能避免编译器对于连续的 `ACCESS_ONCE` 实例进行指令重排

```cpp
int x, y, r;
void f()
{
	ACCESS_ONCE(x) = r;
    ACCESS_ONCE(y) = 1;
}
```

## 运行时的内存乱序

# 线程常见问题
## demo1
> init
```cpp
i = 1;
```

> thread1
```cpp
++i;
```
> thread2
```cpp
--i;
```

> result
- 可能的结果：
  - `i == 0`
  - `i == 1`
  - `i == 2` 

### 分析
- 原因：`++`、`--` 不是原子，其在汇编中有如下子步骤
  - i（内存） ---> X（寄存器）
  - X + 1
  - X ---> i
- **本质**：
  - 多个线程对变量的访问没有同步
    - 解决1：**加锁**可以同步
  - 有缓存（寄存器也可以看成缓存）
    - 解决1：`volatile`---->阻止**编译器**将数据缓存在**寄存器**内而不写回
      - note：阻止不了系统将数据放在CPU缓存
    - 解决2：`memory barrier`---->阻止系统将数据放在缓存
- **多个线程中各个子步骤之间乱序执行，带来结果不稳定**
- 有点像事务的 **更新丢失** 的情况。
  - 拿了之后修改再放回，其中一个结果覆盖了另一个结果

- 解决：
  - 加锁( 其实并不能解决)
### 解决：加锁
> init
```cpp
i = 1;
```

> thread1
```cpp
lock();
++i;
unlock();
```
> thread2
```cpp
lock();
--i;
unlock();
```
- 实际上并不能解决问题，**加锁只给原先的多线程带来了同步，并没有解决缓存的问题**
  - 可能`++i`完了之后，thread1 依然将`i`的值存放在寄存器中，而这个时候如果 thread2 获得了锁，从内存中取到的数将是**还没更新的 i**

### 解决：锁+volatile
- 在《程序员的自我修养》中，左值说使用volatile可以阻止编译器的过度优化，可以阻止编译器为了提高速度将变量缓存在寄存器中，所以可以解决这个问题
  - note：但是不能阻止运行时将数据缓存在CPU缓存中呀，所以CPU缓存的情况**还是不能解决**

### 解决：锁+内存屏障
- note：我个人觉得应该用内存屏障来解决




