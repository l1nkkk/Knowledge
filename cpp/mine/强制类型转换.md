
- [const_cast](#const_cast)
- [static_cast](#static_cast)
- [reinterpret_cast](#reinterpret_cast)
- [dynamic_cast](#dynamic_cast)


- 参考：https://blog.csdn.net/ydar95/article/details/69822540
- 参考：https://www.cnblogs.com/Allen-rg/p/6999360.html
- 参考：https://www.zhihu.com/question/400931816/answer/1279007227
- 参考：《c++ prime》

> 为什么有
- 如果你想做A的事，用一个能做ABCDE的语法去完成是具有风险的。
- C风格的强制转换可能带来一些隐患,让一些问题难以察觉

# const_cast
- **const_cast**：只能改变运算对象的**底层const**
    - 如果对象本身不是一个常量，使用其可以获得写权限是合法的行为。如果本身是一个常量，那么使用其后执行写操作的结果是**未定义的**。
    - 最大作用在于函数的重载上。 
    - 

> demo1：
```cpp
const string & test(const string &s1,const string &s2){
}
```
- 可以用非常量调用这个函数，上面这个返回的结果仍然是const string的引用，需要一个新的test函数，**当实参不是常量时，得到的结果是一个普通的引用**，const_cast可以做到。这里不用const_cast直接调用的话就是无限套娃。
```cpp
string & test(string &s1,string &s2){
  auto &r = test(const_cast<const string&>(s1),const_cast<const string&>(s2);
  return const_cast<string&>(r);
}
```



> demo2：
  - 对象本身不是常量
  - 如果arr的定义为：`const int ary[4]`，那么行为未定义
```cpp
int main() {
    // 原始数组
    int ary[4] = { 1,2,3,4 };

    // 打印数据
    for (int i = 0; i < 4; i++)
        std::cout << ary[i] << "\t";
    std::cout << std::endl;

    // 常量化数组指针
    const int*c_ptr = ary;
    //c_ptr[1] = 233;   //error

    // 通过const_cast<Ty> 去常量
    int *ptr = const_cast<int*>(c_ptr);

    // 修改数据
    for (int i = 0; i < 4; i++)
        ptr[i] += 1;    //pass

    // 打印修改后的数据
    for (int i = 0; i < 4; i++)
        std::cout << ary[i] << "\t";
    std::cout << std::endl;

    return 0;
}

/*  out print
    1   2   3   4
    2   3   4   5
*/
```

# static_cast
- **static_cast**：只要不包含**底层const**(`volatile`也一样)，以及除了reinterpret_cast能做到的以外，其他都可以使用`static_cast`;
  - 当需要把一个较大的算数类型赋值给较小的类型的时候，非常有用
- `static_cast`作用和C语言风格强制转换的效果基本一样
  - demo中可体现
- 由于**没有运行时类型检查来保证转换的安全性**，所以这类型的强制转换和C语言风格的强制转换都有安全隐患
  - demo中可体现
- **上行转换**（派生类==>基类，多重继承也安全）是安全的，**下行转换**（基类转派生类）由于没有**动态类型检查**，所以是不安全的。

```cpp
class baseA{
public:
    // 重点：必须的，否则dynamic_cast编译时报错。因为baseA不是虚类
    virtual void func() {
        cout << "test A" <<endl;
    }
public:
    int a = 1;
};
class baseB{
public:
    int b= 2;
};

class child:public baseA, public baseB{
public:
    int c=4;
};

int main(int argc, char* argv[]) {
    cout << "test1-----------" << endl;
    // test1
    {
        child *c = new child;
        baseA* a = static_cast<baseA*> (c);
        baseB* b = static_cast<baseB*> (c);
        cout << "A :" << a->a << "; a:" << a << endl;
        cout << "B :" << b->b << "; b:" << b <<endl;
        cout << "C :" << c->c << "; c:" << c <<endl;

        // 证明static_cast和c风格转换效果基本一致
        cout << "C风格 again---------" << endl;
        a = (baseA*)(c);
        b = (baseB*)(c);
        cout << "A :" << a->a << "; a:" << a << endl;
        cout << "B :" << b->b << "; b:" << b <<endl;
        cout << "C :" << c->c << "; c:" << c <<endl;
    }

    cout << "test2-----------" << endl;
    // test2
    {
        baseA* a = new baseA;
        child* c = static_cast<child*> (a);
        cout << "A :" << c->a << "; a:" << a <<endl;
        // 没有出错，证明static_cast有安全隐患
        cout << "C :" << c->c << "; c:" << c <<endl;
        c = (child*)a;
        cout << "C :" << c->c << "; c:" << c <<endl;

        // 返回nullptr
        c = dynamic_cast<child*> (a);

        cout  << "c:" << c <<endl;
    }
}

```

```
test1-----------
A :1; a:0x55fd8f80d6e0
B :2; b:0x55fd8f80d6ec
C :4; c:0x55fd8f80d6e0
C风格 again---------
A :1; a:0x55fd8f80d6e0
B :2; b:0x55fd8f80d6ec
C :4; c:0x55fd8f80d6e0
test2-----------
A :1; a:0x55fd8f80d700
C :0; c:0x55fd8f80d700
C :0; c:0x55fd8f80d700
c:0

```

# reinterpret_cast
- reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。
  - **以上都是static_cast做不到的**
- 少用，危险


```cpp
int *a = new int;
double *d = reinterpret_cast<double *>(a);
```
# dynamic_cast
- `dynamic_cast`：在类型转换时会进行动态类型检查
  - 主要用在**基类转子类**中
- `dynamic_cast`强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和**程序运行时的状态**
- **其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查**。
- dynamic_cast的时间和空间代价是相对较高的，在设计时应避免使用。（能用static_cast的就用，比如上行转换都用static_cast，下行转换才用dynamic_cast）
- **这个检查主要来自虚函数**(virtual function) 
  - 后面感兴趣再详细了解下。