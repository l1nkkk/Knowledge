- [同步并发操作（线程同步）](#同步并发操作线程同步)
  - [条件变量](#条件变量)
    - [使用](#使用)
    - [*demo1:条件变量的入门使用（生产者，消费者）](#demo1条件变量的入门使用生产者消费者)
    - [demo2(重要):线程安全的队列](#demo2重要线程安全的队列)
- [异步](#异步)
  - [一个例子体会一下](#一个例子体会一下)
    - [future + async](#future--async)
    - [future + promise](#future--promise)
    - [future + packaged_task](#future--packaged_task)
  - [期望future](#期望future)
    - [demo1：future的参数传递](#demo1future的参数传递)
  - [async](#async)
    - [demo](#demo)
  - [packaged_task](#packaged_task)
    - [demo](#demo-1)
      - [demo5.1：std::packaged_task任务post和get](#demo51stdpackaged_task任务post和get)
      - [demo5.1：std::packaged_task 任务与get_future的使用](#demo51stdpackaged_task-任务与get_future的使用)
  - [promise](#promise)
    - [为future存储异常](#为future存储异常)
    - [demo](#demo-2)
      - [demo6: promise 的初步使用，线程间传值](#demo6-promise-的初步使用线程间传值)
      - [demo7: promise的使用，线程间传递任务（函数）](#demo7-promise的使用线程间传递任务函数)
  - [总结](#总结)
  - [多个线程的等待——share_future](#多个线程的等待share_future)
    - [demo8: shared_future的初步使用](#demo8-shared_future的初步使用)
  - [限定等待时间](#限定等待时间)
    - [时钟](#时钟)
    - [时延](#时延)
    - [时间点](#时间点)
    - [使用超时功能的函数](#使用超时功能的函数)
  - [使用同步操作简化代码](#使用同步操作简化代码)
# 同步并发操作（线程同步）
- 当一个线程等待另一个线程完成时，有以下实现选择。
  - 可以持续的检查共享数据标志
    - 效率太低了
  - 等待间隙检查共享标志。`std::this_thread::sleep_for(std::chrono::milliseconds(100))`
    - 不知道多大合适，试试不够好
  - 条件变量或期望（推荐）
    - 条件变量使用入demo1所示


## 条件变量
- 引入：使用队列在多个线程中转移数据是很常见的。如果做的好的话，**同步操作可以限制在队列本身**，同步问题和条件竞争出现的概率也会降低。
  - 所以可以编写线程安全的队列 demo2(注：和前面的安全stack类似)

### 使用
> wait的使用
```
template <class Predicate>
void wait (unique_lock<mutex>& lck, Predicate pred)
```
- `std::condition_variable` 提供了两种 `wait()` 函数
  - 第一种 : 只使用lck。当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。
  - 第二种：设置了`Predicate`。只有当 `pred` 条件为 `false` 时调用 `wait()` 才会阻塞当前线程，并且在收到其他线程的通知后只有当 `pred` 为 `true` 时才会被解除阻塞。
    - 不用嵌在循环里判断条件

- 时间相关的方法：`wait_for` 、`wait_until`

- **note**：在线程被阻塞时，该函数会自动调用 `lck.unlock()` 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(`notified`，通常是另外某个线程调用 `notify_*` 唤醒了当前线程)，`wait()` 函数也是自动调用 `lck.lock()`，使得 `lck` 的状态和 `wait` 函数被调用时相同。


> notify
- `std::condition_variable::notify_all()`
- `std::condition_variable::notify_one()
`
> std::condition_variable_any
- 与 `std::condition_variable` 类似，只不过 `std::condition_variable_any` 的 `wait` 函数可以接受任何 `lockable` 参数，而 `std::condition_variable` 只能接受 `std::unique_lock<std::mutex>` 类型的参数，除此以外，和 `std::condition_variable` 几乎完全一样。


### *demo1:条件变量的入门使用（生产者，消费者）
- `wait` 唤醒的时候会调用条件判断函数，再此之前已经重新上锁了。
```cpp
std::mutex mtx;
std::queue<std::string> dataQueue;
std::condition_variable cond;

void producer(){
    int a = 0;
    while(true){
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));

        // 可以是lock_guard
        std::lock_guard<std::mutex> lgLock(mtx);
        dataQueue.push("hahaha"+std::to_string(a));

        if(a == 5) {
            dataQueue.push("end");
            // 注：唤醒consumer线程
            cond.notify_one();
            return;
        }
        else ++a;
        cond.notify_one();
    }
}
void consumer(){
    while (true){
        // 必须是unique_lock不能是lock_guard，因为需要随时解锁和上锁
        std::unique_lock<std::mutex> ulLock(mtx);

        // block
        cond.wait(ulLock,[](){return !dataQueue.empty();});

        auto data = dataQueue.front();
        dataQueue.pop();
        std::cout << data << std::endl;
        if("end" == data)
            return;
    }

}

void condDemo(){
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
    std::cout << "bye~" << std::endl;
}
```

> output
``` 
hahaha0
hahaha1
hahaha2
hahaha3
hahaha4
hahaha5
end
bye~
```


### demo2(重要):线程安全的队列
- 功能和demo1一样
```cpp
template<typename T>
class threadSafeThread{
public:
    threadSafeThread()=default;
    threadSafeThread(const threadSafeThread& rv){
        std::lock_guard<std::mutex> lgLock(rv.mtx);
        m_queue = rv.m_queue;
    }
    threadSafeThread &operator = (const threadSafeThread &) = delete;

    void push(T v){
        std::lock_guard<std::mutex> lgLock(mtx);
        m_queue.push(v);
        cond.notify_one();
    }

    bool tryPop(T &rv){
        std::lock_guard<std::mutex> lgLock(mtx);
        if(_empty()) return false;
        else{
            rv = m_queue.front();
            m_queue.pop();
            return true;
        }
    }
    std::shared_ptr<T> tryPop(){
        std::lock_guard<std::mutex> lgLock(mtx);
        if(_empty()) return nullptr;
        else{
            auto res(m_queue.front());
            m_queue.pop();
            return res;
        }
    }

    void waitAndPop(T &rv){
        // lock
        std::unique_lock<std::mutex> lgLock(mtx);
        cond.wait(lgLock, [this](){return !this->_empty();});
        rv = m_queue.front();
        m_queue.pop();
    }
    std::shared_ptr<T> waitAndPop(){

        // lock
        std::unique_lock<std::mutex> lgLock(mtx);
        cond.wait(lgLock, [this](){return !this->_empty();}); // unlock
        // lock
        auto res(m_queue.front());
        m_queue.pop();
        return res;
    }

    bool empty(){
        return _empty();
    }
private:
    bool _empty(){
        return m_queue.empty();
    }
    // 可被const函数修改
    mutable std::mutex mtx;
    std::condition_variable cond;
    std::queue<T> m_queue;
};

threadSafeThread<string> tst;
void producer(){
    int a = 0;
    while(true){
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        tst.push("hahahaha"+std::to_string(a));
        if(a == 5) {
            tst.push("end");
            return;
        }
        else ++a;
    }
}

void comsuper(){
    string data;
    while (true){
        // 必须是unique_lock不能是lock_guard，因为需要随时解锁和上锁
        tst.waitAndPop(data);
        std::cout << data << std::endl;
        if("end" == data)
            return;
    }
}

void queueCondDemo(){
    std::thread t1(comsuper);
    std::thread t2(producer);
    t1.join();
    t2.join();

}
```


> output
``` 
hahahaha0
hahahaha1
hahahaha2
hahahaha3
hahahaha4
hahahaha5
end
```




# 异步
- 异步任务提供者(Provider)
  - `std::promise`
  - `std::packaged_task`
  - `std::async`
## 一个例子体会一下
### future + async
- **分割算法**。对任务的并发拆分，而不是对数据
- std::async 启动一个任务（可能是异步）
- future 用来获取异步任务的返回
> 例子
- 假设有一个大任务：
  - `A B`为可独立数据预处理
  - `C1`操作不需要等待`AB`都预处理完成；`C2`对预处理后的数据进一步处理，需要等待`AB`处理完成后才性
  - `D`和`E`是可独立的数据处理任务
  - `D E`完成后退出
```
A   B   
\   /
  C1(do other thing)
  C2(alter A B done)
/   \
D    E
\    /
 \  /
 Done
```
> 使用future + async的例子
- 注意：`async(&Task::predeal, &t, "preDeal A");`
  - 对比：`future<void> fa = async(&Task::predeal, t, "preDeal A");`
```cpp
class Task{
public:
    void predeal(string a){
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        cout << a + " done" << endl;
    }
    string doJob(string info){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        return info + " done";
    }
};

// future + asyn 最朴素的用法
void demo14_async(){
    Task t;

    // 1. 预处理
    // 注意：调用的是tempt.predeal
    // future<void> fa = async(&Task::predeal, t, "preDeal A");
    // 调用的是t->fa
    future<void> fa = async(&Task::predeal, &t, "preDeal A");
    future<void> fb = async(&Task::predeal, &t, "preDeal B");
    cout << "C1 done" << endl;
    // 2. 同步
    fa.wait();
    fb.wait();
    cout << "merge C2 done" << endl;

    // 3.处理任务
    future<string> fd = async(&Task::doJob, &t, "job D");
    future<string> fe = async(&Task::doJob, &t, "job E");

    cout << fd.get() << endl;
    cout << fe.get() << endl;

    // 4.退出本次处理
    cout << "all done";

}
```
```
C1 done
preDeal A done
preDeal B done
merge C
job D done
job E done
all done
```

### future + promise
```cpp
void demo14_promise(){
    Task t;

    // 1. 预处理
    promise<void> pva;
    promise<void> pvb;
    std::thread ta = std::thread([&t, &pva]() { t.predeal("preDeal A"); pva.set_value();});
    ta.detach();
    std::thread tb = std::thread([&t, &pvb]() { t.predeal("preDeal B"); pvb.set_value();});
    tb.detach();
    cout << "C1 done" << endl;

    // 2. 同步
    pva.get_future().wait();
    pvb.get_future().wait();
    cout << "merge C2 done" << endl;

    // 3. 处理任务
    promise<string> psd;
    promise<string> pse;
    std::thread td = std::thread([&t, &psd]() { psd.set_value(t.doJob("job D")); });
    td.detach();
    std::thread te = std::thread([&t, &pse]() { pse.set_value(t.doJob("job E")); });
    te.detach();
    cout << psd.get_future().get() << endl;
    cout << pse.get_future().get() << endl;

    // 4.退出本次处理
    cout << "all done";
}
```

### future + packaged_task
```cpp
void demo14_packagetTask(){
    Task t;

    // 1.预处理
    packaged_task<void(string)> pta(bind(&Task::predeal, &t, placeholders::_1));
    packaged_task<void(string)> ptb(bind(&Task::predeal, &t, placeholders::_1));
    future<void> fa = pta.get_future();
    future<void> fb = ptb.get_future();
    cout << "C1 done" << endl;

    // 2. 同步
    // 注意：需要右值，移动拷贝
    auto t1 = thread(std::move(pta), std::string("preDeal A"));
    t1.detach();
    auto t2 = thread(std::move(ptb), std::string("preDeal B"));
    t2.detach();
    fa.wait();
    fb.wait();
    cout << "merge C2 done" << endl;

    // 3.处理任务
    packaged_task<string(string)> ptd(bind(&Task::doJob, &t, placeholders::_1));
    packaged_task<string(string)> pte(bind(&Task::doJob, &t, placeholders::_1));
    future<string> fd = ptd.get_future();
    future<string> fe = pte.get_future();
    auto t3 = thread(std::move(ptd), std::string("job D"));
    t3.detach();
    auto t4 = thread(std::move(pte), std::string("job E"));
    t4.detach();
    cout << fd.get() << endl;
    cout << fe.get() << endl;

    // 4.退出本次处理
    cout << "all done";
}
```


## 期望future
- 描述：异步的桥梁，用来同步以及获取异步返回结果。
  - `std::future<T>`: 我的理解为未来期望获得`T`类型的值。
> 为什么需要future
- 用来处理**一次性**同步事件。（只需同步一次的情况）
  - 对标：条件变量。
- 需要获得线程处理后的返回结果。
  - 原先的 `thread` 方式，函数返回要求是`void`的。
> future种类
- 唯一期望：`std::future`
  - 对标：条件变量 `notify_one`
  - 对 `future` 的操作**不是线程安全的**。多个线程访问一个 `future` 对象的时候，需要使用锁进行同步。
- 共享期望：`std::shared_future`
  - 对标：条件变量 `notify_all`
  - 线程安全，不需要同步
> API
- `wait`和`get`：都是阻塞，等待共享状态标志变为 **ready**
  - `wait`：只是等待异步任务完成
  - `get`：等待结束返回异步任务返回值
- `valid()`: 返回 `future` 对象是否拥有共享状态
  - 来源：https://blog.csdn.net/u013271656/article/details/115185870#commentBox
  - 对于使用默认构造产生的 `future` 对象，该函数返回 false。
  - 通过调用std::async、std::packaged_task、std::promise 来初始化 `future` 对象。该函数返回 true。
  - 一旦调用了`std::future::get()` 函数，再调用此函数将返回 false。

> share state 共享状态
- note：可以理解为future。future里面维护了一个共享状态，future为对共享状态的包装。
- 异步任务提供者和一个共享状态相关联（通常为 `std::future` ）,并且可以再相贯线的共享状态（ `std::future` ）上保存一个类型为T的值。

> 细节
- `future` 只能移动不能拷贝。

### demo1：future的参数传递

```cpp
struct optClassX{
    void foo(int a, const std::string& b){
        std::cout << a << ": " << b << std::endl;
    }

    std::string bar(const std::string &s){
        return s+" decorator";
    }
    ~optClassX(){
        static int times = 0;
        std::cout << "Deconstruct:" <<  ++times << std::endl;
    }
};

struct optClassY{
    double valueDeal(double x){
        return x*2;
    }
};

optClassX x;
// 传递1：值传递，注释试试，注释将减少两次析构。async拷贝一次，thread拷贝一次
auto f1 = std::async(&optClassX::foo, x, 3, "l1nkkk");
// 传递2：引用传递
auto f2 = std::async(&optClassX::bar, std::ref(x), "linux");

optClassY y;
// 传递3：指针传递
auto f3 = std::async(&optClassY::valueDeal, &y,3);
void futureDemo2(){
    std::cout << "f1:" ;
    // 注释不注释都没问题
    // f1.get();
    std::cout << "f2:" << f2.get() <<std::endl;
    std::cout << "f3:" << f3.get() <<std::endl;
}
```
> output不固定
```
Deconstruct:1
3: l1nkkk
f1:f2:linux decorator
f3:6
Deconstruct:2
Deconstruct:3
```

## async
- 参考：https://en.cppreference.com/w/cpp/thread/async
- 描述：函数。异步任务提供者
> 函数原型
```cpp
// 版本1
template <class Fn, class... Args>
future<typename result_of<Fn(Args...)>::type>
async(Fn&& fn, Args&&... args);

// 版本2，有policy版本
template <class Fn, class... Args>
future<typename result_of<Fn(Args...)>::type>
async(launch policy, Fn&& fn, Args&&... args);
```
> policy参数
- `std::launch::async`：直接开一个线程执行（asynchronous execution）
- `std::launch::deferred`：等待wait或者get的时候再执行，不开线程，在本线程完成（lazy evaluation）
- `std::launch::async || std::launch::deferred`：异步还是懒汉取决于系统和库的实现。
- `版本1，不设置`：（同上）

> 细节
- async返回的furture必须接收，不然会在`~future()`中block
- async如果选择`deferred` mode，但是没 `get | wait`，则析构时调用
- 如果async的返回没被接收，则自带同步。
  - 因为 tmp_future 析构之前会让 f 被调用完
```cpp
// block
std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f()

std::async(std::launch::async, []{ g(); }); // does not start until f() completes
```

### demo
- https://en.cppreference.com/w/cpp/thread/async
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <future>
#include <string>
#include <mutex>
 
std::mutex m;
struct X {
    void foo(int i, const std::string& str) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << str << ' ' << i << '\n';
    }
    void bar(const std::string& str) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << str << '\n';
    }
    int operator()(int i) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << i << '\n';
        return i + 10;
    }
};
 
template <typename RandomIt>
int parallel_sum(RandomIt beg, RandomIt end)
{
    auto len = end - beg;
    if (len < 1000)
        return std::accumulate(beg, end, 0);
 
    RandomIt mid = beg + len/2;
    auto handle = std::async(std::launch::async,
                             parallel_sum<RandomIt>, mid, end);
    int sum = parallel_sum(beg, mid);
    return sum + handle.get();
}
 
int main()
{
    std::vector<int> v(10000, 1);
    std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\n';
 
    X x;
    // Calls (&x)->foo(42, "Hello") with default policy:
    // may print "Hello 42" concurrently or defer execution
    auto a1 = std::async(&X::foo, &x, 42, "Hello");
    // Calls x.bar("world!") with deferred policy
    // prints "world!" when a2.get() or a2.wait() is called
    auto a2 = std::async(std::launch::deferred, &X::bar, x, "world!");
    // Calls X()(43); with async policy
    // prints "43" concurrently
    auto a3 = std::async(std::launch::async, X(), 43);
    a2.wait();                     // prints "world!"
    std::cout << a3.get() << '\n'; // prints "53"
} // if a1 is not done at this point, destructor of a1 prints "Hello 42" here
```
```
The sum is 10000
43
world!
53
Hello 42
```


## packaged_task
- 描述：一个可调用对象的包装器。让一个可调用对象 绑定的 一个期望，以获得函数返回的结果
  - 与 `std::function` 类似，只不过 `packaged_task` 将结果传递给一个 `std::future` 电源线。
  - 内部包含两个基本元素： task（可调用对象）和 shared state(future)
> 接口
- `get_future`：获取 `packaged_task` 对应的 `future`(共享状态)
  - 只能调用一次
- `valid`：checks if the task object has a valid function
- `reset`：重置 packaged_task 的共享状态，但是保留之前的被包装的任务
```cpp
int triple (int x) { return x*3; }

int main ()
{
    std::packaged_task<int(int)> tsk (triple); // package task
    std::future<int> fut = tsk.get_future();
    std::thread (std::move(tsk), 100).detach();
    std::cout << "The triple of 100 is " << fut.get() << ".\n";


    // re-use same task object:
    // 重点：调用多次
    tsk.reset();
    fut = tsk.get_future();
    std::thread(std::move(tsk), 200).detach();
    std::cout << "Thre triple of 200 is " << fut.get() << ".\n";

    return 0;
}
```

> 细节
- 只能移动

### demo

#### demo5.1：std::packaged_task任务post和get
- 使用 std::packaged_task<void()> 创建任务，其包含了一个无参数无返回值的函数或可调用对象(如果当这个调用有返回值时，返回值会被丢弃)。
- 一个std::packaged_task任务被get_future多次将报错，只能被调用一次。
```cpp
std::mutex mtx;
std::queue<std::packaged_task<void()>> tasks; // 任务
class cmd{
public:
    void done(){
        std::lock_guard<std::mutex> lgm(mtx);
        flag = true;
    }
    bool isDone(){
        std::lock_guard<std::mutex> lgm(mtx);
        return flag;
    }
private:
    std::mutex mtx;
    bool flag = false;
};
cmd c;
void getTaskThread(){
    while(!c.isDone()){
        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lgm(mtx);
            if(tasks.empty())
                continue;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();
    }
}

// 这里使用模板可以传入任意函数签名
template <typename Func> std::future<void> postTaskThread(Func f){
    // 函数签名需要和future对应
    std::packaged_task<void()> task(f);
    // 获得期望
    std::future<void> res = task.get_future();
    std::lock_guard<std::mutex> lgm(mtx);
    tasks.push(std::move(task));
    return res;
}
void taskDemo(){
    std::thread t1(getTaskThread);
    // 传入string()函数，返回值会被丢弃
    postTaskThread([](){
        std::cout << "hello" << std::endl;
        return std::string("www");
    });
    // 传入int()函数
    postTaskThread([](){
        std::cout << " word" << std::endl;
        c.done();
        return 1;
    });
    t1.join();
}
```
> output
```cpp
hello
 word
```

#### demo5.1：std::packaged_task 任务与get_future的使用
```cpp
std::mutex mtx;
std::queue<std::packaged_task<std::string()>> tasks; // 任务
class cmd{
public:
    void done(){
        std::lock_guard<std::mutex> lgm(mtx);
        flag = true;
    }
    bool isDone(){
        std::lock_guard<std::mutex> lgm(mtx);
        return flag;
    }
private:
    std::mutex mtx;
    bool flag = false;
};
cmd c;
void getTaskThread(){
    while(!c.isDone()){
        std::packaged_task<std::string()> task;
        {
            std::lock_guard<std::mutex> lgm(mtx);
            if(tasks.empty())
                continue;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();
    }
}

template <typename Func> std::future<std::string> postTaskThread(Func f){
    // 函数签名需要和future对应
    std::packaged_task<std::string()> task(f);
    std::future<std::string> res = task.get_future();
    std::lock_guard<std::mutex> lgm(mtx);
    tasks.push(std::move(task));
    return res;
}
void taskDemo(){
    std::thread t1(getTaskThread);

    std::future<std::string> f1 = postTaskThread([](){
        std::cout << "hello" << std::endl;
        return std::string("first");
    });

    std::future<std::string> f2 = postTaskThread([](){
        std::cout << " word" << std::endl;
        c.done();
        return std::string("end");
    });
    t1.join();
    std::cout << "f1 res:" << f1.get() << std::endl;
    std::cout << "f2 res:" << f2.get() << std::endl;

}
```
> output
```
hello
 word
f1 res:first
f2 res:end
```

## promise
- 描述：`promise` 对象可以**保存**某一类型 T 的值，该值可被 `future` 对象读取。在 `promise` 对象构造时可以和一个**共享状态**（通常是`std::future`）相关联，并可以在相关联的**共享状态**(`std::future`)上**保存**一个类型为 T 的值。
  - 设置共享状态的值：`promise`
  - 获取共享状态的值：`future`
> 接口
- `get_future`：获取promise对应的future
  - 只能调用一次
- `set_value`：设置future共享状态的值
  - 只能设置一次
- `set_exception`：设置错误
  - 在future get 的时候，被raise
> 细节
- 参考：https://stackoverflow.com/questions/11004273/what-is-stdpromise
- 只能移动
- 默认构造的 `promise` 是inactive的，能够被没有使用的销毁
```cpp
int test()
{
    std::promise<int> pr;
    return 0;
}
// fine, no problems
```

- `get_future` 之后 `promise` 变为 active的状态，且只能被调用一次 `get_future` (note:future只能移动)
```cpp
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();
    return 0;
}
// fine, no problems; fut.get() would block indefinitely
```
```cpp
int test()
{
    std::promise<int> pr;
    auto fut1 = pr.get_future();
    auto fut2 = pr.get_future();  //   Error: "Future already retrieved"
    return 0;
}
```
- 对应的 `future` 要被消费，只能再 `promise` 的生命周期之前，通过 `set_value` 或者 `set_exception` 设置值或错误。
  - 但只能被set一次
```cpp
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();

    {
        std::promise<int> pr2(std::move(pr));
        pr2.set_value(10);
    }

    return fut.get();
}
// Fine, returns "10".
```

```cpp
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();

    {
        std::promise<int> pr2(std::move(pr));
        pr2.set_value(10);
        pr2.set_value(10);  // Error: "Promise already satisfied"
    }

    return fut.get();
}
```
```cpp
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();

    {
        std::promise<int> pr2(std::move(pr));
        pr2.set_exception(std::make_exception_ptr(std::runtime_error("Booboo")));
    }

    return fut.get();
}
// throws the runtime_error exception
```

- 如果 promise die，但是 `future` 被 `get`，则raise错误
```cpp
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();

    {
        std::promise<int> pr2(std::move(pr));
    }   // Error: "broken promise"

    return fut.get();
}
```

### 为future存储异常
- note：**只有promise才可以自己设置**，像 async 都是在运行时出现什么错误就放什么错误。
- std::async 中传递的函数调用遇到异常时，那么这个异常就会存储到“期望”的结果数据中，之后“期望”future的状态被置为“就绪”，之后调用get()会抛出这个存储的异常。 std::packaged_task 也一样存在future中。

> std::promise的做法
<div align="center" style="zoom:60%"><img src="./pic/2-1.png"></div>

### demo
#### demo6: promise 的初步使用，线程间传值
- 发送消息的线程传promise，另一个传future
- https://stackoverflow.com/questions/45626919/stdpromise-set-value-and-thread-safety
  - `set_value`并不是线程安全的。绝了
```cpp
void postPromiseThread(std::promise<std::string>& rpm){
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    rpm.set_value("l1nkkk xixiix");
    std::cout << "msg send" << std::endl;
}
void getPromiseThread(std::future<std::string>& rft){
    std::string msg = rft.get();
    std::cout << "msg recv:" << msg << std::endl;
}
void promiseValDemo(){
    std::promise<std::string> pm;
    std::future<std::string> ft = pm.get_future();
    std::thread t1(postPromiseThread, std::ref(pm));
    std::thread t2(getPromiseThread, std::ref(ft));
    t1.join();
    t2.join();
}

```

> output
```
msg send
msg recv:l1nkkk xixiix
```


#### demo7: promise的使用，线程间传递任务（函数）
```cpp
// 发布端
template<typename Func>
void postTaskThread(std::promise<Func> &rpm, Func fun){
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    // 传递函数
    rpm.set_value(fun);
    std::cout << "func send" << std::endl;
}

// 接收端
template<typename Func, typename ...Args>
void getTaskThread(std::future<Func> &rft, Args&& ...args){
    // 没有任务就阻塞
    auto fun = rft.get();
    fun(std::forward<Args>(args)...);
    std::cout << "func recv" << std::endl;
}

void promiseTaskDemo(){
    auto func = [](std::string &sa, int ib, double dc){
        std::cout << sa << " " << ib << " " << dc << std::endl;
        return "l1nkkk";
    };
    typedef decltype(func) T;

    // 初始化
    std::promise<T> pm;
    std::future<T> ft = pm.get_future();

    std::string input = "hahahha";

    std::thread t1(postTaskThread<T>, std::ref(pm), func);
    std::thread t2(getTaskThread<T,std::string&, int, double>, std::ref(ft), std::ref(input), 1, 3.14);
    t1.join();
    t2.join();
}

```
> output
```
func send
hahahha 1 3.14
func recv
```
## 总结
- async 
  - 是抽象程度最高的异步provider。
  - 不能将 异步的任务 当对象， async 传入任务后，相当于该任务已经 detach 了
  - 一次 async，生成一个共享对象
- packaged_task
  - 抽象程度比 async 低的异步provider
  - 可以将 异步任务 当对象，有点任务模式的味道，一个任务 对应 一个 future，用来任务的同步和获取任务结果。
- promise
  - 抽象程度最低的provider
  - 可以设置 future 的返回值， 甚至可以设置 future 的返回错误
  - 通过promise 和 functional 的封装，可以实现 packaged_task
  - 一个promise，对应一个共享对象

> promise 实现 packaged_task
```cpp
template <typename> class my_task;

template <typename R, typename ...Args>
class my_task<R(Args...)>
{
    std::function<R(Args...)> fn;
    std::promise<R> pr;             // the promise of the result
public:
    template <typename ...Ts>
    explicit my_task(Ts &&... ts) : fn(std::forward<Ts>(ts)...) { }

    template <typename ...Ts>
    void operator()(Ts &&... ts)
    {
        pr.set_value(fn(std::forward<Ts>(ts)...));  // fulfill the promise
    }

    std::future<R> get_future() { return pr.get_future(); }

    // disable copy, default move
};
```

## 多个线程的等待——share_future
- 引入： std::future 也有局限性，在很多线程在等待的时候，只有一个线程能获取等待结果。当多个线程需要等待相同的事件的结果，你就需要使用 std::shared_future 来替代 std::future 了。（注：一个任务加入多个线程处理）
  - 当多线程在没有额外同步的情况下，访问一个独立的 std::future 对象时，就会有数据竞争和未定义的行为。而且其只能get一次。
- 两种期望（仿照 std::unique_ptr 和 std::share
d_ptr ）
  -  唯一期望(unique futures)( std::future<> )
  - 共享期望(shared futures)( std::shared_future<> )
  - 区别： std::future 的实例只能与一个指定事件相关联，而 std::shared_future 的实例就能关联多个事件

> 细节
- 在与数据无关的地方，可以使用 `std::future<void>` 与 `std::shared_future<void>` 的特化模板。
  - 即使async的函数是有返回的也可以
- `std::shared_future` 实例是可拷贝的，`std::future` 只能移动。
- 当需要多个线程等待同一个任务时，可以用`std::shared_future`
- `shared_future` 可以通过某个 `std::future` 对象隐式转换（参见 `std::shared_future` 的构造函数），或者通过 `std::future::share()` 显示转换，无论哪种转换，被转换的那个 `std::future` 对象都会变为 not-valid

### demo8: shared_future的初步使用
- 为了防止多个线程之间再shared_future的竞争，应该使用shared_future的拷贝对象，不能用引用。
<div align="center" style="zoom:80%"><img src="./pic/2-2.png"></div>


```cpp
auto f = [](){
    std::cout << std::this_thread::get_id() << std::endl;
};

// 不能用引用，不然有竞争
void threadTest(std::shared_future<decltype(f)> sft){
    auto res = sft.get();
    res();
}

void sharedFutureDemo(){

    std::promise<decltype(f)> pm;
    // 右值拷贝
    std::shared_future<decltype(f)> sft = pm.get_future();
    std::thread t1(threadTest,sft);
    std::thread t2(threadTest,sft);
    std::thread t3(threadTest,sft);
    // 传递任务
    pm.set_value(f);
    t1.join();
    t2.join();
    t3.join();

}
```

> output

```cpp
139839203915328139839195522624
139839212308032
```

## 限定等待时间
- 线程库使用到的所有C++时间处理工具，都在 std::chrono 命名空间内
- 两种方式
  - 持续时间
  - 绝对时间
  - 注：多数等待函数提供变量，对两种超时方式进行支持。处理持续时间的变量以“_for”作为后缀，处理绝对时间的变量以"_until"作为后缀.（如条件变量std::condition_variable的两个成员wait_for()和wait_until()）

### 时钟
- c++标准库时钟提供4种不同的信息
  - 现在时间。 
    - 通过now()获取（三种时钟都有）
  - 时钟节拍
  - 时间类型
  - 通过时钟节拍的分布，判断时钟是否稳定

> 时钟节拍

时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定————一个时钟一秒有25个节拍，因此一个周期为 std::ratio<1, 25> ，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为 std::ratio<5,2> 

> 稳定时钟
- 当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。
  - `is_steady`静态数据成员为true时，表明这个时钟就是稳定的

> 三种时钟类型
- 稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟 `std::chrono::steady_clock `
- `std::chrono::system_clock` 代表了系统时钟的“实际时间”，并且提供了函数可将时间点转化为time_t类型的值
- `std::chrono::high_resolution_clock` 可能是标准库中提供的具有最小节拍周期(因此具有最高的精度[分辨率])的时钟。


### 时延
- std::chrono::duration<> 
  - https://blog.csdn.net/zhoupian/article/details/104225605
- 应用：

```cpp
std::future<int> f=std::async(some_task);
if(f.wait_for(std::chrono::milliseconds(35))==std::future_status::ready)
    do_something_with(f.get());
```
> 三种状态
- std::future_status::deferred：
- std::future_status::timeout：超时
- std::future_status::ready：已就绪

### 时间点
- std::chrono::time_point<>

### 使用超时功能的函数
-  std::this_thread::sleep_for() 和 std::this_thread::sleep_until() 


## 使用同步操作简化代码

看书
